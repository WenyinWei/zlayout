<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: 边相交检测算法</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2zh_2algorithms_2edge__intersection__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">边相交检测算法</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md166"></a> <em>几何完整性检查的核心算法</em></p>
<h1><a class="anchor" id="autotoc_md167"></a>
概述</h1>
<p>边相交检测用于识别多边形边缘的交叉位置，这对于检测布局错误、自相交多边形和重叠组件至关重要。该算法是EDA工具几何验证的基础。</p>
<h1><a class="anchor" id="autotoc_md168"></a>
问题定义</h1>
<h2><a class="anchor" id="autotoc_md169"></a>
相交类型</h2>
<ul>
<li>**自相交**：同一多边形内的边相互交叉</li>
<li>**多边形间相交**：不同多边形的边相交</li>
<li>**退化情况**：重合边、端点接触</li>
<li>**数值精度**：由于浮点数误差导致的近似相交</li>
</ul>
<h2><a class="anchor" id="autotoc_md170"></a>
数学基础</h2>
<p>对于两个线段P₁P₂和P₃P₄： </p><div class="fragment"><div class="line">存在相交当：</div>
<div class="line">- 线段不平行</div>
<div class="line">- 交点位于两个线段内</div>
<div class="line">- 参数解：P = P₁ + t(P₂ - P₁) = P₃ + s(P₄ - P₃)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md172"></a>
核心算法</h1>
<h2><a class="anchor" id="autotoc_md173"></a>
算法1：暴力搜索 O(n²)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>EdgeIntersectionDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>Intersection {</div>
<div class="line">        Point location;</div>
<div class="line">        <span class="keywordtype">int</span> edge1_polygon_id, edge1_index;</div>
<div class="line">        <span class="keywordtype">int</span> edge2_polygon_id, edge2_index;</div>
<div class="line">        <span class="keywordtype">bool</span> is_proper;  <span class="comment">// 真相交（穿越）还是仅接触</span></div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;Intersection&gt; detectIntersections(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 检查所有多边形间的所有边对</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly1_id = 0; poly1_id &lt; polygons.size(); ++poly1_id) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly2_id = poly1_id; poly2_id &lt; polygons.size(); ++poly2_id) {</div>
<div class="line">                <span class="keyword">auto</span> poly_intersections = checkPolygonPair(</div>
<div class="line">                    polygons[poly1_id], polygons[poly2_id], </div>
<div class="line">                    poly1_id, poly2_id</div>
<div class="line">                );</div>
<div class="line">                intersections.insert(intersections.end(),</div>
<div class="line">                                   poly_intersections.begin(),</div>
<div class="line">                                   poly_intersections.end());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Intersection&gt; checkPolygonPair(</div>
<div class="line">        <span class="keyword">const</span> Polygon&amp; poly1, <span class="keyword">const</span> Polygon&amp; poly2,</div>
<div class="line">        <span class="keywordtype">int</span> poly1_id, <span class="keywordtype">int</span> poly2_id</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        <span class="keyword">auto</span> edges1 = poly1.edges();</div>
<div class="line">        <span class="keyword">auto</span> edges2 = poly2.edges();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; edges1.size(); ++i) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; edges2.size(); ++j) {</div>
<div class="line">                <span class="comment">// 跳过同一多边形中相邻的边</span></div>
<div class="line">                <span class="keywordflow">if</span> (poly1_id == poly2_id &amp;&amp; areAdjacent(i, j, edges1.size())) {</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> intersection = segmentIntersection(</div>
<div class="line">                    edges1[i].first, edges1[i].second,</div>
<div class="line">                    edges2[j].first, edges2[j].second</div>
<div class="line">                );</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (intersection.exists) {</div>
<div class="line">                    intersections.push_back({</div>
<div class="line">                        intersection.point,</div>
<div class="line">                        poly1_id, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i),</div>
<div class="line">                        poly2_id, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(j),</div>
<div class="line">                        intersection.is_proper</div>
<div class="line">                    });</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>IntersectionResult {</div>
<div class="line">        <span class="keywordtype">bool</span> exists;</div>
<div class="line">        Point point;</div>
<div class="line">        <span class="keywordtype">bool</span> is_proper;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    IntersectionResult segmentIntersection(</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2,</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p3, <span class="keyword">const</span> Point&amp; p4</div>
<div class="line">    ) {</div>
<div class="line">        <span class="comment">// 向量表示</span></div>
<div class="line">        <span class="keywordtype">double</span> dx1 = p2.x - p1.x, dy1 = p2.y - p1.y;</div>
<div class="line">        <span class="keywordtype">double</span> dx2 = p4.x - p3.x, dy2 = p4.y - p3.y;</div>
<div class="line">        <span class="keywordtype">double</span> dx3 = p1.x - p3.x, dy3 = p1.y - p3.y;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 叉积计算行列式</span></div>
<div class="line">        <span class="keywordtype">double</span> denominator = dx1 * dy2 - dy1 * dx2;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 检查直线是否平行</span></div>
<div class="line">        <span class="keywordflow">if</span> (std::abs(denominator) &lt; 1e-10) {</div>
<div class="line">            <span class="keywordflow">return</span> {<span class="keyword">false</span>, Point(), <span class="keyword">false</span>};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 计算参数</span></div>
<div class="line">        <span class="keywordtype">double</span> t = (dx2 * dy3 - dy2 * dx3) / denominator;</div>
<div class="line">        <span class="keywordtype">double</span> s = (dx1 * dy3 - dy1 * dx3) / denominator;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 检查交点是否在两个线段内</span></div>
<div class="line">        <span class="keywordtype">bool</span> within_seg1 = (t &gt;= 0.0 &amp;&amp; t &lt;= 1.0);</div>
<div class="line">        <span class="keywordtype">bool</span> within_seg2 = (s &gt;= 0.0 &amp;&amp; s &lt;= 1.0);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (within_seg1 &amp;&amp; within_seg2) {</div>
<div class="line">            Point intersection_point(</div>
<div class="line">                p1.x + t * dx1,</div>
<div class="line">                p1.y + t * dy1</div>
<div class="line">            );</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 检查是否为真相交（不只是接触）</span></div>
<div class="line">            <span class="keywordtype">bool</span> is_proper = (t &gt; 1e-10 &amp;&amp; t &lt; 1.0 - 1e-10) &amp;&amp;</div>
<div class="line">                            (s &gt; 1e-10 &amp;&amp; s &lt; 1.0 - 1e-10);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> {<span class="keyword">true</span>, intersection_point, is_proper};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {<span class="keyword">false</span>, Point(), <span class="keyword">false</span>};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md174"></a>
算法2：扫描线 O((n+k) log n)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>SweepLineIntersectionDetector {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>Event {</div>
<div class="line">        <span class="keywordtype">double</span> x;</div>
<div class="line">        <span class="keyword">enum</span> Type { START, END, INTERSECTION } type;</div>
<div class="line">        <span class="keywordtype">int</span> edge_id;</div>
<div class="line">        Point point;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> Event&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (std::abs(x - other.x) &gt; 1e-10) <span class="keywordflow">return</span> x &lt; other.x;</div>
<div class="line">            <span class="keywordflow">return</span> type &lt; other.type;  <span class="comment">// START在END之前处理</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>Edge {</div>
<div class="line">        Point start, end;</div>
<div class="line">        <span class="keywordtype">int</span> polygon_id, edge_index;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> y_at_x(<span class="keywordtype">double</span> x)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (std::abs(end.x - start.x) &lt; 1e-10) <span class="keywordflow">return</span> start.y;</div>
<div class="line">            <span class="keywordtype">double</span> t = (x - start.x) / (end.x - start.x);</div>
<div class="line">            <span class="keywordflow">return</span> start.y + t * (end.y - start.y);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;Intersection&gt; detectIntersectionsSweepLine(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Event&gt; events;</div>
<div class="line">        std::vector&lt;Edge&gt; edges;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 为所有边创建事件</span></div>
<div class="line">        <span class="keywordtype">int</span> edge_id = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly_id = 0; poly_id &lt; polygons.size(); ++poly_id) {</div>
<div class="line">            <span class="keyword">auto</span> poly_edges = polygons[poly_id].edges();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> edge_idx = 0; edge_idx &lt; poly_edges.size(); ++edge_idx) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = poly_edges[edge_idx];</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 确保从左到右的顺序</span></div>
<div class="line">                Point left = edge.first, right = edge.second;</div>
<div class="line">                <span class="keywordflow">if</span> (left.x &gt; right.x) std::swap(left, right);</div>
<div class="line">                </div>
<div class="line">                edges.push_back({left, right, </div>
<div class="line">                               <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_id), </div>
<div class="line">                               <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(edge_idx)});</div>
<div class="line">                </div>
<div class="line">                events.push_back({left.x, Event::START, edge_id, left});</div>
<div class="line">                events.push_back({right.x, Event::END, edge_id, right});</div>
<div class="line">                </div>
<div class="line">                edge_id++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 按x坐标排序事件</span></div>
<div class="line">        std::sort(events.begin(), events.end());</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 扫描线状态结构（按y坐标排序的集合）</span></div>
<div class="line">        std::set&lt;int, <span class="keyword">decltype</span>([<span class="keyword">this</span>](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">            <span class="keywordflow">return</span> this-&gt;compareEdgesByY(a, b);</div>
<div class="line">        })&gt; active_edges(</div>
<div class="line">            [<span class="keyword">this</span>](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> compareEdgesByY(a, b); }</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 处理事件</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) {</div>
<div class="line">            <span class="keywordflow">if</span> (event.type == Event::START) {</div>
<div class="line">                <span class="comment">// 将边添加到活跃集合</span></div>
<div class="line">                <span class="keyword">auto</span> [iter, inserted] = active_edges.insert(event.edge_id);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 检查与邻居的相交</span></div>
<div class="line">                <span class="keywordflow">if</span> (iter != active_edges.begin()) {</div>
<div class="line">                    <span class="keyword">auto</span> prev = std::prev(iter);</div>
<div class="line">                    checkAndAddIntersection(*prev, event.edge_id, </div>
<div class="line">                                          intersections, edges);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> next = std::next(iter);</div>
<div class="line">                <span class="keywordflow">if</span> (next != active_edges.end()) {</div>
<div class="line">                    checkAndAddIntersection(event.edge_id, *next,</div>
<div class="line">                                          intersections, edges);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event.type == Event::END) {</div>
<div class="line">                <span class="comment">// 从活跃集合中移除边</span></div>
<div class="line">                <span class="keyword">auto</span> iter = active_edges.find(event.edge_id);</div>
<div class="line">                <span class="keywordflow">if</span> (iter != active_edges.end()) {</div>
<div class="line">                    <span class="comment">// 检查邻居现在是否相交</span></div>
<div class="line">                    <span class="keyword">auto</span> prev = (iter != active_edges.begin()) ? </div>
<div class="line">                               std::prev(iter) : active_edges.end();</div>
<div class="line">                    <span class="keyword">auto</span> next = std::next(iter);</div>
<div class="line">                    </div>
<div class="line">                    active_edges.erase(iter);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (prev != active_edges.end() &amp;&amp; next != active_edges.end()) {</div>
<div class="line">                        checkAndAddIntersection(*prev, *next,</div>
<div class="line">                                              intersections, edges);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Edge&gt; edges_storage;</div>
<div class="line">    <span class="keywordtype">double</span> current_sweep_x;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> compareEdgesByY(<span class="keywordtype">int</span> edge_a, <span class="keywordtype">int</span> edge_b) {</div>
<div class="line">        <span class="keywordtype">double</span> y_a = edges_storage[edge_a].y_at_x(current_sweep_x);</div>
<div class="line">        <span class="keywordtype">double</span> y_b = edges_storage[edge_b].y_at_x(current_sweep_x);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (std::abs(y_a - y_b) &gt; 1e-10) <span class="keywordflow">return</span> y_a &lt; y_b;</div>
<div class="line">        <span class="keywordflow">return</span> edge_a &lt; edge_b;  <span class="comment">// 打破平局</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> checkAndAddIntersection(<span class="keywordtype">int</span> edge1_id, <span class="keywordtype">int</span> edge2_id,</div>
<div class="line">                                std::vector&lt;Intersection&gt;&amp; intersections,</div>
<div class="line">                                <span class="keyword">const</span> std::vector&lt;Edge&gt;&amp; edges) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge1 = edges[edge1_id];</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge2 = edges[edge2_id];</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> intersection = segmentIntersection(</div>
<div class="line">            edge1.start, edge1.end,</div>
<div class="line">            edge2.start, edge2.end</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (intersection.exists) {</div>
<div class="line">            intersections.push_back({</div>
<div class="line">                intersection.point,</div>
<div class="line">                edge1.polygon_id, edge1.edge_index,</div>
<div class="line">                edge2.polygon_id, edge2.edge_index,</div>
<div class="line">                intersection.is_proper</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md176"></a>
Python实现</h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>EdgeIntersectionDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;针对EDA布局优化的边相交检测器&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>detect_intersections(polygons, include_touching=False):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        检测多边形集合中的所有边相交</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        参数:</span></div>
<div class="line"><span class="stringliteral">            polygons: 多边形对象列表</span></div>
<div class="line"><span class="stringliteral">            include_touching: 是否包含端点接触作为相交</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        返回:</span></div>
<div class="line"><span class="stringliteral">            相交信息字典列表</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        intersections = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 使用空间索引提高效率</span></div>
<div class="line">        spatial_index = SpatialIndex()</div>
<div class="line">        edge_data = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 索引所有边</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            edges = polygon.edges</div>
<div class="line">            <span class="keywordflow">for</span> edge_id, (start, end) <span class="keywordflow">in</span> enumerate(edges):</div>
<div class="line">                bbox = BoundingBox.from_points([start, end])</div>
<div class="line">                edge_info = {</div>
<div class="line">                    <span class="stringliteral">&#39;polygon_id&#39;</span>: poly_id,</div>
<div class="line">                    <span class="stringliteral">&#39;edge_id&#39;</span>: edge_id,</div>
<div class="line">                    <span class="stringliteral">&#39;start&#39;</span>: start,</div>
<div class="line">                    <span class="stringliteral">&#39;end&#39;</span>: end,</div>
<div class="line">                    <span class="stringliteral">&#39;bbox&#39;</span>: bbox</div>
<div class="line">                }</div>
<div class="line">                spatial_index.insert(bbox, len(edge_data))</div>
<div class="line">                edge_data.append(edge_info)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查相交</span></div>
<div class="line">        checked_pairs = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> i, edge1 <span class="keywordflow">in</span> enumerate(edge_data):</div>
<div class="line">            <span class="comment"># 查询附近的边</span></div>
<div class="line">            candidates = spatial_index.query(edge1[<span class="stringliteral">&#39;bbox&#39;</span>])</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> candidates:</div>
<div class="line">                <span class="keywordflow">if</span> i &gt;= j:  <span class="comment"># 避免重复检查</span></div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                    </div>
<div class="line">                edge2 = edge_data[j]</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 跳过同一多边形中的相邻边</span></div>
<div class="line">                <span class="keywordflow">if</span> (edge1[<span class="stringliteral">&#39;polygon_id&#39;</span>] == edge2[<span class="stringliteral">&#39;polygon_id&#39;</span>] <span class="keywordflow">and</span> </div>
<div class="line">                    abs(edge1[<span class="stringliteral">&#39;edge_id&#39;</span>] - edge2[<span class="stringliteral">&#39;edge_id&#39;</span>]) &lt;= 1):</div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                </div>
<div class="line">                pair = (i, j)</div>
<div class="line">                <span class="keywordflow">if</span> pair <span class="keywordflow">in</span> checked_pairs:</div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                checked_pairs.add(pair)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 检查相交</span></div>
<div class="line">                intersection = EdgeIntersectionDetector._segment_intersection(</div>
<div class="line">                    edge1[<span class="stringliteral">&#39;start&#39;</span>], edge1[<span class="stringliteral">&#39;end&#39;</span>],</div>
<div class="line">                    edge2[<span class="stringliteral">&#39;start&#39;</span>], edge2[<span class="stringliteral">&#39;end&#39;</span>]</div>
<div class="line">                )</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;exists&#39;</span>]:</div>
<div class="line">                    <span class="keywordflow">if</span> include_touching <span class="keywordflow">or</span> intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]:</div>
<div class="line">                        intersections.append({</div>
<div class="line">                            <span class="stringliteral">&#39;point&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;polygon1_id&#39;</span>: edge1[<span class="stringliteral">&#39;polygon_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;edge1_id&#39;</span>: edge1[<span class="stringliteral">&#39;edge_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;polygon2_id&#39;</span>: edge2[<span class="stringliteral">&#39;polygon_id&#39;</span>], </div>
<div class="line">                            <span class="stringliteral">&#39;edge2_id&#39;</span>: edge2[<span class="stringliteral">&#39;edge_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;is_proper&#39;</span>: intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]</div>
<div class="line">                        })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>_segment_intersection(p1, p2, p3, p4):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;计算两个线段之间的相交&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 方向向量</span></div>
<div class="line">        d1 = (p2[0] - p1[0], p2[1] - p1[1])</div>
<div class="line">        d2 = (p4[0] - p3[0], p4[1] - p3[1])</div>
<div class="line">        d3 = (p1[0] - p3[0], p1[1] - p3[1])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 叉积计算行列式</span></div>
<div class="line">        denominator = d1[0] * d2[1] - d1[1] * d2[0]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查平行线</span></div>
<div class="line">        <span class="keywordflow">if</span> abs(denominator) &lt; 1e-10:</div>
<div class="line">            <span class="keywordflow">return</span> {<span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">False</span>, <span class="stringliteral">&#39;point&#39;</span>: <span class="keywordtype">None</span>, <span class="stringliteral">&#39;is_proper&#39;</span>: <span class="keyword">False</span>}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 计算参数</span></div>
<div class="line">        t = (d2[0] * d3[1] - d2[1] * d3[0]) / denominator</div>
<div class="line">        s = (d1[0] * d3[1] - d1[1] * d3[0]) / denominator</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查交点是否在两个线段内</span></div>
<div class="line">        <span class="keywordflow">if</span> 0.0 &lt;= t &lt;= 1.0 <span class="keywordflow">and</span> 0.0 &lt;= s &lt;= 1.0:</div>
<div class="line">            intersection_point = (</div>
<div class="line">                p1[0] + t * d1[0],</div>
<div class="line">                p1[1] + t * d1[1]</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 判断是否为真相交</span></div>
<div class="line">            epsilon = 1e-10</div>
<div class="line">            is_proper = (epsilon &lt; t &lt; 1.0 - epsilon <span class="keywordflow">and</span> </div>
<div class="line">                        epsilon &lt; s &lt; 1.0 - epsilon)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> {</div>
<div class="line">                <span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">True</span>,</div>
<div class="line">                <span class="stringliteral">&#39;point&#39;</span>: intersection_point,</div>
<div class="line">                <span class="stringliteral">&#39;is_proper&#39;</span>: is_proper</div>
<div class="line">            }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">False</span>, <span class="stringliteral">&#39;point&#39;</span>: <span class="keywordtype">None</span>, <span class="stringliteral">&#39;is_proper&#39;</span>: <span class="keyword">False</span>}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md178"></a>
复杂度分析</h1>
<h2><a class="anchor" id="autotoc_md179"></a>
时间复杂度比较</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">算法   </th><th class="markdownTableHeadNone">预处理   </th><th class="markdownTableHeadNone">检测   </th><th class="markdownTableHeadNone">总计   </th><th class="markdownTableHeadNone">空间复杂度    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">暴力搜索   </td><td class="markdownTableBodyNone">无   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">扫描线   </td><td class="markdownTableBodyNone">O(nm log(nm))   </td><td class="markdownTableBodyNone">O((nm+k)log(nm))   </td><td class="markdownTableBodyNone">O((nm+k)log(nm))   </td><td class="markdownTableBodyNone">O(nm)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">空间索引   </td><td class="markdownTableBodyNone">O(nm log(nm))   </td><td class="markdownTableBodyNone">O(nm log(nm) + k)   </td><td class="markdownTableBodyNone">O(nm log(nm) + k)   </td><td class="markdownTableBodyNone">O(nm)   </td></tr>
</table>
<p>其中：</p><ul>
<li><code>n</code> = 多边形数量</li>
<li><code>m</code> = 每个多边形的平均边数</li>
<li><code>k</code> = 发现的相交数量</li>
</ul>
<h2><a class="anchor" id="autotoc_md180"></a>
性能基准测试</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>benchmark_intersection_algorithms():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;比较不同相交算法的性能&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    polygon_counts = [10, 50, 100, 500]</div>
<div class="line">    edge_counts = [4, 8, 16, 32]  <span class="comment"># 每个多边形的平均边数</span></div>
<div class="line">    </div>
<div class="line">    results = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> n_polys <span class="keywordflow">in</span> polygon_counts:</div>
<div class="line">        <span class="keywordflow">for</span> avg_edges <span class="keywordflow">in</span> edge_counts:</div>
<div class="line">            test_polygons = generate_complex_layout(n_polys, avg_edges)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 暴力方法</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            bf_detector = BruteForceDetector()</div>
<div class="line">            bf_results = bf_detector.detect_intersections(test_polygons)</div>
<div class="line">            bf_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 扫描线方法</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            sl_detector = SweepLineDetector()</div>
<div class="line">            sl_results = sl_detector.detect_intersections(test_polygons)</div>
<div class="line">            sl_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 空间索引方法</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            si_detector = EdgeIntersectionDetector()</div>
<div class="line">            si_results = si_detector.detect_intersections(test_polygons)</div>
<div class="line">            si_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            key = f<span class="stringliteral">&quot;{n_polys}p_{avg_edges}e&quot;</span></div>
<div class="line">            results[key] = {</div>
<div class="line">                <span class="stringliteral">&#39;brute_force&#39;</span>: bf_time,</div>
<div class="line">                <span class="stringliteral">&#39;sweep_line&#39;</span>: sl_time,</div>
<div class="line">                <span class="stringliteral">&#39;spatial_index&#39;</span>: si_time,</div>
<div class="line">                <span class="stringliteral">&#39;intersections_found&#39;</span>: len(si_results)</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            print(f<span class="stringliteral">&quot;{key}: 暴力={bf_time:.3f}s, 扫描线={sl_time:.3f}s, 空间索引={si_time:.3f}s&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md182"></a>
交互式教程</h1>
<h2><a class="anchor" id="autotoc_md183"></a>
教程1：基础相交检测</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 创建包含已知相交的测试用例</span></div>
<div class="line">polygons = [</div>
<div class="line">    <span class="comment"># 自相交的蝴蝶结多边形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([</div>
<div class="line">        (0, 0), (4, 4), (4, 0), (0, 4)  <span class="comment"># 创建X形相交</span></div>
<div class="line">    ]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 两个重叠的矩形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(5, 1, 3, 2),  <span class="comment"># 矩形1</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(6, 0, 3, 3),  <span class="comment"># 矩形2 - 与矩形1重叠</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 与矩形相交的三角形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([</div>
<div class="line">        (10, 0), (13, 0), (11.5, 3)   <span class="comment"># 三角形</span></div>
<div class="line">    ]),</div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(11, 1, 2, 1),   <span class="comment"># 与三角形相交的矩形</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">detector = zlayout.EdgeIntersectionDetector()</div>
<div class="line">intersections = detector.detect_intersections(polygons)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;发现 {len(intersections)} 个边相交:&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> i, intersection <span class="keywordflow">in</span> enumerate(intersections):</div>
<div class="line">    print(f<span class="stringliteral">&quot;相交 {i+1}:&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  位置: ({intersection[&#39;point&#39;][0]:.2f}, {intersection[&#39;point&#39;][1]:.2f})&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  之间: 多边形 {intersection[&#39;polygon1_id&#39;]} 边 {intersection[&#39;edge1_id&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;        多边形 {intersection[&#39;polygon2_id&#39;]} 边 {intersection[&#39;edge2_id&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  类型: {&#39;真相交&#39; if intersection[&#39;is_proper&#39;] else &#39;端点接触&#39;}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_polygon_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_polygon.html">zlayout::geometry::Polygon</a></div><div class="ttdoc">Polygon class supporting both convex and concave polygons.</div><div class="ttdef"><b>Definition</b> <a href="polygon_8hpp_source.html#l00025">polygon.hpp:25</a></div></div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_rectangle_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout::geometry::Rectangle</a></div><div class="ttdoc">Axis-aligned rectangle for bounding boxes and simple EDA components.</div><div class="ttdef"><b>Definition</b> <a href="rectangle_8hpp_source.html#l00026">rectangle.hpp:26</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md184"></a>
教程2：自相交验证</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>validate_polygon_integrity(polygon):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;检查多边形是否有自相交&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 创建单个多边形列表用于相交检测</span></div>
<div class="line">    result = detector.detect_intersections([polygon])</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 只筛选自相交</span></div>
<div class="line">    self_intersections = [</div>
<div class="line">        inter <span class="keywordflow">for</span> inter <span class="keywordflow">in</span> result </div>
<div class="line">        <span class="keywordflow">if</span> inter[<span class="stringliteral">&#39;polygon1_id&#39;</span>] == inter[<span class="stringliteral">&#39;polygon2_id&#39;</span>]</div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> self_intersections:</div>
<div class="line">        print(f<span class="stringliteral">&quot;多边形有 {len(self_intersections)} 个自相交:&quot;</span>)</div>
<div class="line">        <span class="keywordflow">for</span> inter <span class="keywordflow">in</span> self_intersections:</div>
<div class="line">            print(f<span class="stringliteral">&quot;  边 {inter[&#39;edge1_id&#39;]} 与边 {inter[&#39;edge2_id&#39;]} 相交&quot;</span>)</div>
<div class="line">            print(f<span class="stringliteral">&quot;  在点: ({inter[&#39;point&#39;][0]:.3f}, {inter[&#39;point&#39;][1]:.3f})&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        print(<span class="stringliteral">&quot;多边形有效（无自相交）&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 测试各种多边形类型</span></div>
<div class="line">test_cases = [</div>
<div class="line">    <span class="comment"># 有效的简单多边形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (4, 0), (4, 3), (0, 3)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 自相交的蝴蝶结</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (2, 2), (2, 0), (0, 2)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 复杂的有效多边形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (3, 0), (4, 1), (3, 3), (1, 4), (0, 2)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 8字形状（自相交）</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 1), (1, 2), (2, 1), (3, 2), (4, 1), (3, 0), (2, 1), (1, 0)])</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> i, polygon <span class="keywordflow">in</span> enumerate(test_cases):</div>
<div class="line">    print(f<span class="stringliteral">&quot;\n=== 测试用例 {i+1} ===&quot;</span>)</div>
<div class="line">    is_valid = validate_polygon_integrity(polygon)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md186"></a>
实际应用</h1>
<h2><a class="anchor" id="autotoc_md187"></a>
1. 布局验证</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>LayoutVerifier:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self.detector = EdgeIntersectionDetector()</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>comprehensive_intersection_check(self, layout):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;执行全面的相交分析&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        report = {</div>
<div class="line">            <span class="stringliteral">&#39;self_intersections&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;component_overlaps&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;critical_intersections&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;total_intersections&#39;</span>: 0</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 获取所有相交</span></div>
<div class="line">        all_intersections = self.detector.detect_intersections(</div>
<div class="line">            layout.components, include_touching=<span class="keyword">True</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        report[<span class="stringliteral">&#39;total_intersections&#39;</span>] = len(all_intersections)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> intersection <span class="keywordflow">in</span> all_intersections:</div>
<div class="line">            <span class="comment"># 分类相交类型</span></div>
<div class="line">            <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>] == intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]:</div>
<div class="line">                <span class="comment"># 自相交</span></div>
<div class="line">                report[<span class="stringliteral">&#39;self_intersections&#39;</span>].append(intersection)</div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># 组件重叠</span></div>
<div class="line">                component1 = layout.components[intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>]]</div>
<div class="line">                component2 = layout.components[intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]]</div>
<div class="line">                </div>
<div class="line">                overlap_info = {</div>
<div class="line">                    <span class="stringliteral">&#39;intersection&#39;</span>: intersection,</div>
<div class="line">                    <span class="stringliteral">&#39;component1_name&#39;</span>: component1.name,</div>
<div class="line">                    <span class="stringliteral">&#39;component2_name&#39;</span>: component2.name,</div>
<div class="line">                    <span class="stringliteral">&#39;component1_layer&#39;</span>: component1.layer,</div>
<div class="line">                    <span class="stringliteral">&#39;component2_layer&#39;</span>: component2.layer</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 检查是否为关键相交</span></div>
<div class="line">                <span class="keywordflow">if</span> (component1.layer == component2.layer <span class="keywordflow">and</span> </div>
<div class="line">                    intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]):</div>
<div class="line">                    report[<span class="stringliteral">&#39;critical_intersections&#39;</span>].append(overlap_info)</div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    report[<span class="stringliteral">&#39;component_overlaps&#39;</span>].append(overlap_info)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> report</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>generate_fix_suggestions(self, intersection_report):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;为修复相交生成建议&quot;&quot;&quot;</span></div>
<div class="line">        suggestions = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 自相交修复</span></div>
<div class="line">        <span class="keywordflow">for</span> self_inter <span class="keywordflow">in</span> intersection_report[<span class="stringliteral">&#39;self_intersections&#39;</span>]:</div>
<div class="line">            suggestions.append({</div>
<div class="line">                <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;self_intersection&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;严重&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;message&#39;</span>: f<span class="stringliteral">&quot;多边形有自相交边。考虑简化几何形状。&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;location&#39;</span>: self_inter[<span class="stringliteral">&#39;point&#39;</span>]</div>
<div class="line">            })</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 关键重叠修复</span></div>
<div class="line">        <span class="keywordflow">for</span> critical <span class="keywordflow">in</span> intersection_report[<span class="stringliteral">&#39;critical_intersections&#39;</span>]:</div>
<div class="line">            suggestions.append({</div>
<div class="line">                <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;component_overlap&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;高&#39;</span>, </div>
<div class="line">                <span class="stringliteral">&#39;message&#39;</span>: f<span class="stringliteral">&quot;组件 &#39;{critical[&#39;component1_name&#39;]}&#39; 和 &quot;</span></div>
<div class="line">                          f<span class="stringliteral">&quot;&#39;{critical[&#39;component2_name&#39;]}&#39; 在同一层重叠&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;suggestion&#39;</span>: <span class="stringliteral">&quot;调整组件位置或修改布线&quot;</span></div>
<div class="line">            })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> suggestions</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md188"></a>
2. 制造约束检查</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>check_manufacturing_constraints(layout, process_rules):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;检查违反制造规则的相交&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    violations = []</div>
<div class="line">    intersections = detector.detect_intersections(layout.components)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> intersection <span class="keywordflow">in</span> intersections:</div>
<div class="line">        comp1 = layout.components[intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>]]</div>
<div class="line">        comp2 = layout.components[intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查同层相交</span></div>
<div class="line">        <span class="keywordflow">if</span> comp1.layer == comp2.layer:</div>
<div class="line">            layer_rules = process_rules.get(comp1.layer, {})</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]:</div>
<div class="line">                <span class="comment"># 同层的真相交总是违规</span></div>
<div class="line">                violations.append({</div>
<div class="line">                    <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;same_layer_overlap&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;error&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;layer&#39;</span>: comp1.layer,</div>
<div class="line">                    <span class="stringliteral">&#39;location&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>],</div>
<div class="line">                    <span class="stringliteral">&#39;components&#39;</span>: [comp1.name, comp2.name]</div>
<div class="line">                })</div>
<div class="line">            </div>
<div class="line">        <span class="comment"># 检查层间违规</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># 某些层组合不允许相交</span></div>
<div class="line">            forbidden_combinations = process_rules.get(<span class="stringliteral">&#39;forbidden_intersections&#39;</span>, [])</div>
<div class="line">            layer_pair = tuple(sorted([comp1.layer, comp2.layer]))</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> layer_pair <span class="keywordflow">in</span> forbidden_combinations:</div>
<div class="line">                violations.append({</div>
<div class="line">                    <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;forbidden_layer_intersection&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;warning&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;layers&#39;</span>: layer_pair,</div>
<div class="line">                    <span class="stringliteral">&#39;location&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>]</div>
<div class="line">                })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> violations</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md190"></a>
高级优化</h1>
<h2><a class="anchor" id="autotoc_md191"></a>
Bentley-Ottmann算法</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>BentleyOttmannDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;最优的O((n+k) log n)相交检测&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>detect_intersections_optimal(self, polygons):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Bentley-Ottmann扫描线算法&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        events = []</div>
<div class="line">        edges = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 创建初始事件</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            poly_edges = polygon.edges</div>
<div class="line">            <span class="keywordflow">for</span> edge_id, (start, end) <span class="keywordflow">in</span> enumerate(poly_edges):</div>
<div class="line">                <span class="comment"># 确保从左到右的顺序</span></div>
<div class="line">                <span class="keywordflow">if</span> start[0] &gt; end[0] <span class="keywordflow">or</span> (start[0] == end[0] <span class="keywordflow">and</span> start[1] &gt; end[1]):</div>
<div class="line">                    start, end = end, start</div>
<div class="line">                </div>
<div class="line">                edge_data = {</div>
<div class="line">                    <span class="stringliteral">&#39;id&#39;</span>: len(edges),</div>
<div class="line">                    <span class="stringliteral">&#39;polygon_id&#39;</span>: poly_id,</div>
<div class="line">                    <span class="stringliteral">&#39;edge_id&#39;</span>: edge_id,</div>
<div class="line">                    <span class="stringliteral">&#39;start&#39;</span>: start,</div>
<div class="line">                    <span class="stringliteral">&#39;end&#39;</span>: end</div>
<div class="line">                }</div>
<div class="line">                edges.append(edge_data)</div>
<div class="line">                </div>
<div class="line">                events.append(Event(start[0], <span class="stringliteral">&#39;start&#39;</span>, len(edges) - 1))</div>
<div class="line">                events.append(Event(end[0], <span class="stringliteral">&#39;end&#39;</span>, len(edges) - 1))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 排序事件</span></div>
<div class="line">        events.sort(key=<span class="keyword">lambda</span> e: (e.x, e.type == <span class="stringliteral">&#39;end&#39;</span>))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 扫描线状态</span></div>
<div class="line">        active_edges = BalancedBST()  <span class="comment"># Y序的活跃边</span></div>
<div class="line">        intersections = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> event <span class="keywordflow">in</span> events:</div>
<div class="line">            <span class="keywordflow">if</span> event.type == <span class="stringliteral">&#39;start&#39;</span>:</div>
<div class="line">                edge = edges[event.edge_id]</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 插入边并查找邻居</span></div>
<div class="line">                node = active_edges.insert(edge)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 检查与邻居的相交</span></div>
<div class="line">                <span class="keywordflow">if</span> node.predecessor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edges[node.predecessor.edge_id], edge, intersections</div>
<div class="line">                    )</div>
<div class="line">                <span class="keywordflow">if</span> node.successor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edge, edges[node.successor.edge_id], intersections</div>
<div class="line">                    )</div>
<div class="line">                    </div>
<div class="line">            <span class="keywordflow">elif</span> event.type == <span class="stringliteral">&#39;end&#39;</span>:</div>
<div class="line">                edge = edges[event.edge_id]</div>
<div class="line">                node = active_edges.find(edge)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 检查前驱和后继现在是否相交</span></div>
<div class="line">                <span class="keywordflow">if</span> node.predecessor <span class="keywordflow">and</span> node.successor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edges[node.predecessor.edge_id],</div>
<div class="line">                        edges[node.successor.edge_id], </div>
<div class="line">                        intersections</div>
<div class="line">                    )</div>
<div class="line">                </div>
<div class="line">                active_edges.delete(node)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md193"></a>
性能总结</h1>
<p>边相交检测特征：</p>
<p><b>算法选择：</b></p><ul>
<li>**暴力搜索**：边总数&lt;100时使用</li>
<li>**空间索引**：最佳通用算法</li>
<li>**扫描线**：稀疏相交时最优</li>
<li>**Bentley-Ottmann**：最佳理论复杂度</li>
</ul>
<p><b>性能扩展：</b></p><ul>
<li>小数据集（&lt;1K边）：所有算法都可接受</li>
<li>中等数据集（1K-10K边）：推荐空间索引</li>
<li>大数据集（&gt;10K边）：扫描线或Bentley-Ottmann</li>
</ul>
<p><b>内存要求：</b></p><ul>
<li>暴力搜索：O(1)工作内存</li>
<li>空间索引：O(n)用于索引结构</li>
<li>扫描线：O(n)用于事件队列和活跃集合</li>
</ul>
<p><b>实际考虑：</b></p><ol type="1">
<li>空间索引具有最佳平均情况性能</li>
<li>扫描线在相交密度低时表现优异</li>
<li>数值精度对稳健结果至关重要</li>
<li>验证用例可能提前终止</li>
</ol>
<p>该算法是几何验证的基础，能够可靠检测布局错误并确保EDA工作流中的几何完整性。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
