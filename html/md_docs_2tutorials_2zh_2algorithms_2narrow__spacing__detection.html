<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: 窄间距检测算法</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2zh_2algorithms_2narrow__spacing__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">窄间距检测算法</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md194"></a> <em>制造约束验证的核心算法</em></p>
<h1><a class="anchor" id="autotoc_md195"></a>
概述</h1>
<p>窄间距检测用于识别几何特征间距小于制造公差的区域。该算法是设计规则检查(DRC)的关键组成部分，确保先进半导体工艺的制造可靠性。</p>
<h1><a class="anchor" id="autotoc_md196"></a>
问题定义</h1>
<h2><a class="anchor" id="autotoc_md197"></a>
制造挑战</h2>
<ul>
<li>**蚀刻分辨率**：过于接近的特征可能在蚀刻过程中合并</li>
<li>**光刻限制**：光刻工艺的光学分辨率约束</li>
<li>**工艺变化**：制造公差要求最小间距</li>
<li>**电气问题**：寄生耦合和串扰</li>
</ul>
<h2><a class="anchor" id="autotoc_md198"></a>
数学基础</h2>
<p>对于两个线段或多边形边： </p><div class="fragment"><div class="line">最小距离 = min(点到线距离(p1, 线段2), </div>
<div class="line">              点到线距离(p2, 线段1),</div>
<div class="line">              线段到线段距离(线段1, 线段2))</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md200"></a>
核心算法</h1>
<h2><a class="anchor" id="autotoc_md201"></a>
方法1：暴力搜索 O(n²)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>NarrowSpacingDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>SpacingViolation {</div>
<div class="line">        Point point1, point2;</div>
<div class="line">        <span class="keywordtype">double</span> distance;</div>
<div class="line">        <span class="keywordtype">int</span> polygon1_id, polygon2_id;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;SpacingViolation&gt; detectNarrowSpacing(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons,</div>
<div class="line">        <span class="keywordtype">double</span> min_spacing = 0.1</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;SpacingViolation&gt; violations;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 检查不同多边形之间的间距</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; polygons.size(); ++i) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i + 1; j &lt; polygons.size(); ++j) {</div>
<div class="line">                <span class="keyword">auto</span> poly_violations = checkPolygonPair(</div>
<div class="line">                    polygons[i], polygons[j], min_spacing, i, j</div>
<div class="line">                );</div>
<div class="line">                violations.insert(violations.end(), </div>
<div class="line">                                poly_violations.begin(), </div>
<div class="line">                                poly_violations.end());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;SpacingViolation&gt; checkPolygonPair(</div>
<div class="line">        <span class="keyword">const</span> Polygon&amp; poly1, <span class="keyword">const</span> Polygon&amp; poly2,</div>
<div class="line">        <span class="keywordtype">double</span> min_spacing, <span class="keywordtype">int</span> id1, <span class="keywordtype">int</span> id2</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;SpacingViolation&gt; violations;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> edges1 = poly1.edges();</div>
<div class="line">        <span class="keyword">auto</span> edges2 = poly2.edges();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge1 : edges1) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge2 : edges2) {</div>
<div class="line">                <span class="keywordtype">double</span> dist = segmentToSegmentDistance(</div>
<div class="line">                    edge1.first, edge1.second,</div>
<div class="line">                    edge2.first, edge2.second</div>
<div class="line">                );</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; min_spacing) {</div>
<div class="line">                    <span class="keyword">auto</span> closest_points = findClosestPoints(edge1, edge2);</div>
<div class="line">                    violations.push_back({</div>
<div class="line">                        closest_points.first,</div>
<div class="line">                        closest_points.second,</div>
<div class="line">                        dist, id1, id2</div>
<div class="line">                    });</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> segmentToSegmentDistance(</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2,</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p3, <span class="keyword">const</span> Point&amp; p4</div>
<div class="line">    ) {</div>
<div class="line">        <span class="comment">// 使用最近点算法实现</span></div>
<div class="line">        <span class="keywordflow">return</span> calculateMinimumDistance(p1, p2, p3, p4);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md202"></a>
方法2：空间索引优化 O(n log n)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>OptimizedSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.spatial_index = <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds)</div>
<div class="line">        self.polygon_cache = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>detect_narrow_spacing(self, polygons, min_spacing=0.1):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;使用空间索引的优化间距检测&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 构建空间索引</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            expanded_bbox = bbox.expand(min_spacing)</div>
<div class="line">            self.spatial_index.insert(expanded_bbox, poly_id)</div>
<div class="line">            self.polygon_cache[poly_id] = polygon</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 只检查附近的多边形对</span></div>
<div class="line">        checked_pairs = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            search_bbox = bbox.expand(min_spacing * 1.5)</div>
<div class="line">            </div>
<div class="line">            nearby_ids = self.spatial_index.query_range(search_bbox)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> nearby_id <span class="keywordflow">in</span> nearby_ids:</div>
<div class="line">                <span class="keywordflow">if</span> nearby_id != poly_id:</div>
<div class="line">                    pair = tuple(sorted([poly_id, nearby_id]))</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> pair <span class="keywordflow">not</span> <span class="keywordflow">in</span> checked_pairs:</div>
<div class="line">                        checked_pairs.add(pair)</div>
<div class="line">                        </div>
<div class="line">                        nearby_polygon = self.polygon_cache[nearby_id]</div>
<div class="line">                        pair_violations = self._check_polygon_pair(</div>
<div class="line">                            polygon, nearby_polygon, </div>
<div class="line">                            min_spacing, poly_id, nearby_id</div>
<div class="line">                        )</div>
<div class="line">                        violations.extend(pair_violations)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_check_polygon_pair(self, poly1, poly2, min_spacing, id1, id2):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;检查两个多边形之间的间距&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 快速包围盒检查</span></div>
<div class="line">        bbox1 = poly1.bounding_box()</div>
<div class="line">        bbox2 = poly2.bounding_box()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> bbox1.distance_to(bbox2) &gt;= min_spacing:</div>
<div class="line">            <span class="keywordflow">return</span> violations  <span class="comment"># 距离太远</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 详细的边到边检查</span></div>
<div class="line">        <span class="keywordflow">for</span> edge1 <span class="keywordflow">in</span> poly1.edges:</div>
<div class="line">            <span class="keywordflow">for</span> edge2 <span class="keywordflow">in</span> poly2.edges:</div>
<div class="line">                dist = self._segment_distance(edge1, edge2)</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> dist &lt; min_spacing:</div>
<div class="line">                    closest_pts = self._closest_points_on_segments(edge1, edge2)</div>
<div class="line">                    violations.append({</div>
<div class="line">                        <span class="stringliteral">&#39;point1&#39;</span>: closest_pts[0],</div>
<div class="line">                        <span class="stringliteral">&#39;point2&#39;</span>: closest_pts[1], </div>
<div class="line">                        <span class="stringliteral">&#39;distance&#39;</span>: dist,</div>
<div class="line">                        <span class="stringliteral">&#39;polygon1_id&#39;</span>: id1,</div>
<div class="line">                        <span class="stringliteral">&#39;polygon2_id&#39;</span>: id2</div>
<div class="line">                    })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
<div class="ttc" id="aclasszlayout_1_1spatial_1_1_quad_tree_html"><div class="ttname"><a href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout::spatial::QuadTree</a></div><div class="ttdoc">Quadtree spatial index for efficient range and intersection queries.</div><div class="ttdef"><b>Definition</b> <a href="quadtree_8hpp_source.html#l00120">quadtree.hpp:120</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md204"></a>
复杂度分析</h1>
<h2><a class="anchor" id="autotoc_md205"></a>
时间复杂度比较</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">方法   </th><th class="markdownTableHeadNone">预处理   </th><th class="markdownTableHeadNone">查询   </th><th class="markdownTableHeadNone">总体   </th><th class="markdownTableHeadNone">空间复杂度    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">暴力搜索   </td><td class="markdownTableBodyNone">无   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">空间索引   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(k log n)   </td><td class="markdownTableBodyNone">O(n log n + km²)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">R-tree   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n log n + km²)   </td><td class="markdownTableBodyNone">O(n)   </td></tr>
</table>
<p>其中：</p><ul>
<li><code>n</code> = 多边形数量</li>
<li><code>m</code> = 每个多边形的平均边数 <br  />
</li>
<li><code>k</code> = 每次查询的平均邻近多边形数</li>
</ul>
<h2><a class="anchor" id="autotoc_md206"></a>
性能扩展性</h2>
<div class="fragment"><div class="line"><span class="comment"># 不同方法的基准测试</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>benchmark_spacing_detection():</div>
<div class="line">    polygon_counts = [10, 50, 100, 500, 1000]</div>
<div class="line">    </div>
<div class="line">    results = {</div>
<div class="line">        <span class="stringliteral">&#39;brute_force&#39;</span>: [],</div>
<div class="line">        <span class="stringliteral">&#39;spatial_index&#39;</span>: [],</div>
<div class="line">        <span class="stringliteral">&#39;rtree&#39;</span>: []</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> n_polygons <span class="keywordflow">in</span> polygon_counts:</div>
<div class="line">        <span class="comment"># 生成测试数据</span></div>
<div class="line">        test_polygons = generate_test_layout(n_polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 暴力方法</span></div>
<div class="line">        start = time.perf_counter()</div>
<div class="line">        bf_detector = BruteForceDetector()</div>
<div class="line">        bf_results = bf_detector.detect_narrow_spacing(test_polygons, 0.1)</div>
<div class="line">        bf_time = time.perf_counter() - start</div>
<div class="line">        results[<span class="stringliteral">&#39;brute_force&#39;</span>].append(bf_time)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 空间索引方法</span></div>
<div class="line">        start = time.perf_counter()</div>
<div class="line">        si_detector = OptimizedSpacingDetector(world_bounds)</div>
<div class="line">        si_results = si_detector.detect_narrow_spacing(test_polygons, 0.1)</div>
<div class="line">        si_time = time.perf_counter() - start</div>
<div class="line">        results[<span class="stringliteral">&#39;spatial_index&#39;</span>].append(si_time)</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;N={n_polygons}: 暴力={bf_time:.3f}s, 空间索引={si_time:.3f}s, &quot;</span></div>
<div class="line">              f<span class="stringliteral">&quot;加速比={bf_time/si_time:.1f}x&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 预期输出显示大数据集的显著加速</span></div>
<div class="line">benchmark_results = benchmark_spacing_detection()</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md208"></a>
交互式教程</h1>
<h2><a class="anchor" id="autotoc_md209"></a>
教程1：基础间距检查</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 创建包含间距违规的测试布局</span></div>
<div class="line">components = [</div>
<div class="line">    <span class="comment"># 两个非常接近的矩形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 0, 10, 5),    <span class="comment"># 组件1</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(10.05, 0, 10, 5), <span class="comment"># 组件2 - 只有0.05间距！</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 另一对具有适当间距的组件</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 10, 8, 4),     <span class="comment"># 组件3  </span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(10, 10, 8, 4),    <span class="comment"># 组件4 - 2.0间距</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">detector = zlayout.NarrowSpacingDetector()</div>
<div class="line">violations = detector.detect_narrow_spacing(</div>
<div class="line">    components, </div>
<div class="line">    min_spacing=0.1  <span class="comment"># 100nm最小间距</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;发现 {len(violations)} 个间距违规&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> i, violation <span class="keywordflow">in</span> enumerate(violations):</div>
<div class="line">    print(f<span class="stringliteral">&quot;违规 {i+1}: {violation[&#39;distance&#39;]:.3f} &lt; 0.1&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  多边形 {violation[&#39;polygon1_id&#39;]} 和 {violation[&#39;polygon2_id&#39;]} 之间&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_rectangle_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout::geometry::Rectangle</a></div><div class="ttdoc">Axis-aligned rectangle for bounding boxes and simple EDA components.</div><div class="ttdef"><b>Definition</b> <a href="rectangle_8hpp_source.html#l00026">rectangle.hpp:26</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md210"></a>
教程2：工艺节点验证</h2>
<div class="fragment"><div class="line"><span class="comment"># 不同工艺节点有不同的间距要求</span></div>
<div class="line">process_spacing_rules = {</div>
<div class="line">    <span class="stringliteral">&quot;28nm&quot;</span>: 0.028,  <span class="comment"># 28nm最小间距</span></div>
<div class="line">    <span class="stringliteral">&quot;14nm&quot;</span>: 0.014,  <span class="comment"># 14nm最小间距</span></div>
<div class="line">    <span class="stringliteral">&quot;7nm&quot;</span>:  0.007,  <span class="comment"># 7nm最小间距</span></div>
<div class="line">    <span class="stringliteral">&quot;3nm&quot;</span>:  0.003,  <span class="comment"># 3nm最小间距</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>validate_process_node(layout, process_node):</div>
<div class="line">    min_spacing = process_spacing_rules[process_node]</div>
<div class="line">    </div>
<div class="line">    violations = detector.detect_narrow_spacing(</div>
<div class="line">        layout.components, </div>
<div class="line">        min_spacing=min_spacing</div>
<div class="line">    )</div>
<div class="line">    </div>
<div class="line">    critical_violations = [</div>
<div class="line">        v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> violations </div>
<div class="line">        <span class="keywordflow">if</span> v[<span class="stringliteral">&#39;distance&#39;</span>] &lt; min_spacing * 0.8  <span class="comment"># 小于最小值的80%</span></div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">        <span class="stringliteral">&#39;total_violations&#39;</span>: len(violations),</div>
<div class="line">        <span class="stringliteral">&#39;critical_violations&#39;</span>: len(critical_violations),</div>
<div class="line">        <span class="stringliteral">&#39;pass&#39;</span>: len(violations) == 0,</div>
<div class="line">        <span class="stringliteral">&#39;min_distance_found&#39;</span>: min([v[<span class="stringliteral">&#39;distance&#39;</span>] <span class="keywordflow">for</span> v <span class="keywordflow">in</span> violations]) <span class="keywordflow">if</span> violations <span class="keywordflow">else</span> float(<span class="stringliteral">&#39;inf&#39;</span>)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 在不同工艺节点上测试</span></div>
<div class="line">test_layout = generate_cpu_layout()</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> process <span class="keywordflow">in</span> [<span class="stringliteral">&quot;28nm&quot;</span>, <span class="stringliteral">&quot;14nm&quot;</span>, <span class="stringliteral">&quot;7nm&quot;</span>, <span class="stringliteral">&quot;3nm&quot;</span>]:</div>
<div class="line">    result = validate_process_node(test_layout, process)</div>
<div class="line">    status = <span class="stringliteral">&quot;通过&quot;</span> <span class="keywordflow">if</span> result[<span class="stringliteral">&#39;pass&#39;</span>] <span class="keywordflow">else</span> <span class="stringliteral">&quot;失败&quot;</span></div>
<div class="line">    </div>
<div class="line">    print(f<span class="stringliteral">&quot;{process} 工艺: {status}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  违规数: {result[&#39;total_violations&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  严重违规: {result[&#39;critical_violations&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  最小距离: {result[&#39;min_distance_found&#39;]:.4f}&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md212"></a>
实际应用</h1>
<h2><a class="anchor" id="autotoc_md213"></a>
1. 先进工艺DRC</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>AdvancedDRCChecker:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, process_rules):</div>
<div class="line">        self.rules = process_rules</div>
<div class="line">        self.detectors = {}</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>comprehensive_spacing_check(self, layout):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;多层间距验证&quot;&quot;&quot;</span></div>
<div class="line">        all_violations = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 不同层有不同的间距规则</span></div>
<div class="line">        layer_rules = {</div>
<div class="line">            <span class="stringliteral">&#39;metal1&#39;</span>: self.rules[<span class="stringliteral">&#39;metal1_spacing&#39;</span>],</div>
<div class="line">            <span class="stringliteral">&#39;metal2&#39;</span>: self.rules[<span class="stringliteral">&#39;metal2_spacing&#39;</span>], </div>
<div class="line">            <span class="stringliteral">&#39;via&#39;</span>: self.rules[<span class="stringliteral">&#39;via_spacing&#39;</span>],</div>
<div class="line">            <span class="stringliteral">&#39;poly&#39;</span>: self.rules[<span class="stringliteral">&#39;poly_spacing&#39;</span>]</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> layer_name, min_spacing <span class="keywordflow">in</span> layer_rules.items():</div>
<div class="line">            layer_components = layout.get_layer_components(layer_name)</div>
<div class="line">            </div>
<div class="line">            violations = self.detect_narrow_spacing(</div>
<div class="line">                layer_components, min_spacing</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 特殊情况的额外检查</span></div>
<div class="line">            <span class="keywordflow">if</span> layer_name == <span class="stringliteral">&#39;via&#39;</span>:</div>
<div class="line">                violations.extend(self._check_via_to_via_spacing(</div>
<div class="line">                    layer_components, min_spacing * 1.2</div>
<div class="line">                ))</div>
<div class="line">            </div>
<div class="line">            all_violations[layer_name] = violations</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> all_violations</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md214"></a>
2. 寄生提取指导</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>analyze_coupling_risk(spacing_violations, frequency_mhz=1000):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;分析间距违规的电气耦合风险&quot;&quot;&quot;</span></div>
<div class="line">    coupling_analysis = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> violation <span class="keywordflow">in</span> spacing_violations:</div>
<div class="line">        <span class="comment"># 计算耦合电容</span></div>
<div class="line">        distance = violation[<span class="stringliteral">&#39;distance&#39;</span>]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 简单平行板电容器模型</span></div>
<div class="line">        <span class="comment"># C = ε₀ × εᵣ × A / d</span></div>
<div class="line">        coupling_capacitance = calculate_coupling_capacitance(</div>
<div class="line">            distance, </div>
<div class="line">            conductor_width=1.0,  <span class="comment"># 假设1μm宽度</span></div>
<div class="line">            dielectric_constant=3.9  <span class="comment"># SiO2</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 估算耦合噪声</span></div>
<div class="line">        coupling_noise_mv = estimate_coupling_noise(</div>
<div class="line">            coupling_capacitance, frequency_mhz</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        risk_level = <span class="stringliteral">&quot;高&quot;</span> <span class="keywordflow">if</span> coupling_noise_mv &gt; 50 <span class="keywordflow">else</span> \</div>
<div class="line">                    <span class="stringliteral">&quot;中&quot;</span> <span class="keywordflow">if</span> coupling_noise_mv &gt; 10 <span class="keywordflow">else</span> <span class="stringliteral">&quot;低&quot;</span></div>
<div class="line">        </div>
<div class="line">        coupling_analysis.append({</div>
<div class="line">            <span class="stringliteral">&#39;violation&#39;</span>: violation,</div>
<div class="line">            <span class="stringliteral">&#39;coupling_capacitance_ff&#39;</span>: coupling_capacitance * 1e15,</div>
<div class="line">            <span class="stringliteral">&#39;coupling_noise_mv&#39;</span>: coupling_noise_mv,</div>
<div class="line">            <span class="stringliteral">&#39;risk_level&#39;</span>: risk_level</div>
<div class="line">        })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> coupling_analysis</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md216"></a>
高级优化</h1>
<h2><a class="anchor" id="autotoc_md217"></a>
大数据集的GPU加速</h2>
<div class="fragment"><div class="line"><span class="comment"># 对于极大布局（数百万多边形）</span></div>
<div class="line"><span class="keyword">class </span>GPUSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, use_cuda=True):</div>
<div class="line">        self.use_cuda = use_cuda <span class="keywordflow">and</span> cuda_available()</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>detect_narrow_spacing_gpu(self, polygons, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;GPU加速的间距检测&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.use_cuda:</div>
<div class="line">            <span class="keywordflow">return</span> self.fallback_cpu_detection(polygons, min_spacing)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 将多边形转换为GPU友好格式</span></div>
<div class="line">        gpu_polygons = self._prepare_gpu_data(polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 启动CUDA内核进行并行距离计算</span></div>
<div class="line">        violations = self._cuda_spacing_kernel(gpu_polygons, min_spacing)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> self._format_violations(violations)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_cuda_spacing_kernel(self, gpu_data, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;用于并行距离计算的CUDA内核&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 伪CUDA代码</span></div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        __global__ void spacing_kernel(</span></div>
<div class="line"><span class="stringliteral">            float* polygon_data, </span></div>
<div class="line"><span class="stringliteral">            int num_polygons,</span></div>
<div class="line"><span class="stringliteral">            float min_spacing,</span></div>
<div class="line"><span class="stringliteral">            int* violations_out</span></div>
<div class="line"><span class="stringliteral">        ) {</span></div>
<div class="line"><span class="stringliteral">            int idx = blockIdx.x * blockDim.x + threadIdx.x;</span></div>
<div class="line"><span class="stringliteral">            // 并行距离计算...</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">pass</span>  <span class="comment"># 实现细节</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md218"></a>
内存高效的流式处理</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>StreamingSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, chunk_size=1000):</div>
<div class="line">        self.chunk_size = chunk_size</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>detect_large_layout(self, layout_iterator, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;处理无法装入内存的大布局&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        polygon_chunks = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 分块处理</span></div>
<div class="line">        <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> self._chunk_iterator(layout_iterator, self.chunk_size):</div>
<div class="line">            chunk_violations = self._process_chunk(chunk, min_spacing)</div>
<div class="line">            violations.extend(chunk_violations)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 保留最近的块用于跨块检查</span></div>
<div class="line">            polygon_chunks.append(chunk)</div>
<div class="line">            <span class="keywordflow">if</span> len(polygon_chunks) &gt; 3:  <span class="comment"># 在内存中保留3个块</span></div>
<div class="line">                polygon_chunks.pop(0)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 检查块之间的交互</span></div>
<div class="line">            <span class="keywordflow">if</span> len(polygon_chunks) &gt; 1:</div>
<div class="line">                cross_violations = self._check_chunk_boundaries(</div>
<div class="line">                    polygon_chunks[-2], polygon_chunks[-1], min_spacing</div>
<div class="line">                )</div>
<div class="line">                violations.extend(cross_violations)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md220"></a>
性能总结</h1>
<p>窄间距检测性能特征：</p>
<p><b>算法复杂度：</b></p><ul>
<li>**暴力搜索**：O(n²m²) - 对大布局来说过于昂贵</li>
<li>**空间索引**：O(n log n + km²) - 生产环境实用</li>
<li>**GPU加速**：O(n log n) 配合大规模并行计算</li>
</ul>
<p><b>内存使用：</b></p><ul>
<li>**基础**：O(n) 用于多边形存储</li>
<li>**空间索引**：额外O(n) 用于索引结构</li>
<li>**流式处理**：O(chunk_size) 适用于任意大小的布局</li>
</ul>
<p><b>实际性能：</b></p><ul>
<li>1K多边形：~10ms（空间索引）</li>
<li>10K多边形：~100ms（空间索引） <br  />
</li>
<li>100K多边形：~1s（空间索引）</li>
<li>1M+多边形：推荐GPU加速</li>
</ul>
<p><b>优化指南：</b></p><ol type="1">
<li>超过100个多边形时使用空间索引</li>
<li>考虑包围盒预筛选</li>
<li>超过100K多边形时使用GPU加速</li>
<li>内存受限环境下使用流式处理</li>
</ol>
<p>该算法是现代EDA流程的核心，在保持合理计算性能的同时，确保先进工艺节点的可靠制造。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
