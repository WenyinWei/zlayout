<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: Edge Intersection Detection Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2en_2algorithms_2edge__intersection__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Edge Intersection Detection Algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> <em>Geometry Validation for Layout Integrity</em></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>Edge intersection detection identifies where polygon edges cross each other, which is critical for detecting layout errors, self-intersecting polygons, and overlapping components. This algorithm forms the foundation of geometric validation in EDA tools.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Problem Definition</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Types of Intersections</h2>
<ul>
<li><b>Self-intersection</b>: Edges within the same polygon cross each other</li>
<li><b>Polygon-to-polygon</b>: Edges from different polygons intersect</li>
<li><b>Degenerate cases</b>: Coincident edges, touching endpoints</li>
<li><b>Numerical precision</b>: Near-intersections due to floating-point errors</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Mathematical Foundation</h2>
<p>For two line segments P₁P₂ and P₃P₄: </p><div class="fragment"><div class="line">Intersection exists if:</div>
<div class="line">- Line segments are not parallel</div>
<div class="line">- Intersection point lies within both segments</div>
<div class="line">- Parametric solution: P = P₁ + t(P₂ - P₁) = P₃ + s(P₄ - P₃)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md6"></a>
Core Algorithms</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Algorithm 1: Brute Force O(n²)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>EdgeIntersectionDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>Intersection {</div>
<div class="line">        Point location;</div>
<div class="line">        <span class="keywordtype">int</span> edge1_polygon_id, edge1_index;</div>
<div class="line">        <span class="keywordtype">int</span> edge2_polygon_id, edge2_index;</div>
<div class="line">        <span class="keywordtype">bool</span> is_proper;  <span class="comment">// True if segments cross, false if just touching</span></div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;Intersection&gt; detectIntersections(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check all edge pairs between all polygons</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly1_id = 0; poly1_id &lt; polygons.size(); ++poly1_id) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly2_id = poly1_id; poly2_id &lt; polygons.size(); ++poly2_id) {</div>
<div class="line">                <span class="keyword">auto</span> poly_intersections = checkPolygonPair(</div>
<div class="line">                    polygons[poly1_id], polygons[poly2_id], </div>
<div class="line">                    poly1_id, poly2_id</div>
<div class="line">                );</div>
<div class="line">                intersections.insert(intersections.end(),</div>
<div class="line">                                   poly_intersections.begin(),</div>
<div class="line">                                   poly_intersections.end());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Intersection&gt; checkPolygonPair(</div>
<div class="line">        <span class="keyword">const</span> Polygon&amp; poly1, <span class="keyword">const</span> Polygon&amp; poly2,</div>
<div class="line">        <span class="keywordtype">int</span> poly1_id, <span class="keywordtype">int</span> poly2_id</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        <span class="keyword">auto</span> edges1 = poly1.edges();</div>
<div class="line">        <span class="keyword">auto</span> edges2 = poly2.edges();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; edges1.size(); ++i) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; edges2.size(); ++j) {</div>
<div class="line">                <span class="comment">// Skip adjacent edges within same polygon</span></div>
<div class="line">                <span class="keywordflow">if</span> (poly1_id == poly2_id &amp;&amp; areAdjacent(i, j, edges1.size())) {</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> intersection = segmentIntersection(</div>
<div class="line">                    edges1[i].first, edges1[i].second,</div>
<div class="line">                    edges2[j].first, edges2[j].second</div>
<div class="line">                );</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (intersection.exists) {</div>
<div class="line">                    intersections.push_back({</div>
<div class="line">                        intersection.point,</div>
<div class="line">                        poly1_id, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i),</div>
<div class="line">                        poly2_id, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(j),</div>
<div class="line">                        intersection.is_proper</div>
<div class="line">                    });</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>IntersectionResult {</div>
<div class="line">        <span class="keywordtype">bool</span> exists;</div>
<div class="line">        Point point;</div>
<div class="line">        <span class="keywordtype">bool</span> is_proper;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    IntersectionResult segmentIntersection(</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2,</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p3, <span class="keyword">const</span> Point&amp; p4</div>
<div class="line">    ) {</div>
<div class="line">        <span class="comment">// Vector representations</span></div>
<div class="line">        <span class="keywordtype">double</span> dx1 = p2.x - p1.x, dy1 = p2.y - p1.y;</div>
<div class="line">        <span class="keywordtype">double</span> dx2 = p4.x - p3.x, dy2 = p4.y - p3.y;</div>
<div class="line">        <span class="keywordtype">double</span> dx3 = p1.x - p3.x, dy3 = p1.y - p3.y;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Cross product for determinant</span></div>
<div class="line">        <span class="keywordtype">double</span> denominator = dx1 * dy2 - dy1 * dx2;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check if lines are parallel</span></div>
<div class="line">        <span class="keywordflow">if</span> (std::abs(denominator) &lt; 1e-10) {</div>
<div class="line">            <span class="keywordflow">return</span> {<span class="keyword">false</span>, Point(), <span class="keyword">false</span>};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Calculate parameters</span></div>
<div class="line">        <span class="keywordtype">double</span> t = (dx2 * dy3 - dy2 * dx3) / denominator;</div>
<div class="line">        <span class="keywordtype">double</span> s = (dx1 * dy3 - dy1 * dx3) / denominator;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check if intersection is within both segments</span></div>
<div class="line">        <span class="keywordtype">bool</span> within_seg1 = (t &gt;= 0.0 &amp;&amp; t &lt;= 1.0);</div>
<div class="line">        <span class="keywordtype">bool</span> within_seg2 = (s &gt;= 0.0 &amp;&amp; s &lt;= 1.0);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (within_seg1 &amp;&amp; within_seg2) {</div>
<div class="line">            Point intersection_point(</div>
<div class="line">                p1.x + t * dx1,</div>
<div class="line">                p1.y + t * dy1</div>
<div class="line">            );</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Check if it&#39;s a proper intersection (not just touching)</span></div>
<div class="line">            <span class="keywordtype">bool</span> is_proper = (t &gt; 1e-10 &amp;&amp; t &lt; 1.0 - 1e-10) &amp;&amp;</div>
<div class="line">                            (s &gt; 1e-10 &amp;&amp; s &lt; 1.0 - 1e-10);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> {<span class="keyword">true</span>, intersection_point, is_proper};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {<span class="keyword">false</span>, Point(), <span class="keyword">false</span>};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Algorithm 2: Sweep Line O((n+k) log n)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>SweepLineIntersectionDetector {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>Event {</div>
<div class="line">        <span class="keywordtype">double</span> x;</div>
<div class="line">        <span class="keyword">enum</span> Type { START, END, INTERSECTION } type;</div>
<div class="line">        <span class="keywordtype">int</span> edge_id;</div>
<div class="line">        Point point;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> Event&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (std::abs(x - other.x) &gt; 1e-10) <span class="keywordflow">return</span> x &lt; other.x;</div>
<div class="line">            <span class="keywordflow">return</span> type &lt; other.type;  <span class="comment">// Process START before END</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>Edge {</div>
<div class="line">        Point start, end;</div>
<div class="line">        <span class="keywordtype">int</span> polygon_id, edge_index;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> y_at_x(<span class="keywordtype">double</span> x)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (std::abs(end.x - start.x) &lt; 1e-10) <span class="keywordflow">return</span> start.y;</div>
<div class="line">            <span class="keywordtype">double</span> t = (x - start.x) / (end.x - start.x);</div>
<div class="line">            <span class="keywordflow">return</span> start.y + t * (end.y - start.y);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;Intersection&gt; detectIntersectionsSweepLine(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;Event&gt; events;</div>
<div class="line">        std::vector&lt;Edge&gt; edges;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Create events for all edges</span></div>
<div class="line">        <span class="keywordtype">int</span> edge_id = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> poly_id = 0; poly_id &lt; polygons.size(); ++poly_id) {</div>
<div class="line">            <span class="keyword">auto</span> poly_edges = polygons[poly_id].edges();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> edge_idx = 0; edge_idx &lt; poly_edges.size(); ++edge_idx) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = poly_edges[edge_idx];</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Ensure left-to-right ordering</span></div>
<div class="line">                Point left = edge.first, right = edge.second;</div>
<div class="line">                <span class="keywordflow">if</span> (left.x &gt; right.x) std::swap(left, right);</div>
<div class="line">                </div>
<div class="line">                edges.push_back({left, right, </div>
<div class="line">                               <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_id), </div>
<div class="line">                               <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(edge_idx)});</div>
<div class="line">                </div>
<div class="line">                events.push_back({left.x, Event::START, edge_id, left});</div>
<div class="line">                events.push_back({right.x, Event::END, edge_id, right});</div>
<div class="line">                </div>
<div class="line">                edge_id++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Sort events by x-coordinate</span></div>
<div class="line">        std::sort(events.begin(), events.end());</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Sweep line status structure (ordered set by y-coordinate)</span></div>
<div class="line">        std::set&lt;int, <span class="keyword">decltype</span>([<span class="keyword">this</span>](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">            <span class="keywordflow">return</span> this-&gt;compareEdgesByY(a, b);</div>
<div class="line">        })&gt; active_edges(</div>
<div class="line">            [<span class="keyword">this</span>](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> compareEdgesByY(a, b); }</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;Intersection&gt; intersections;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Process events</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : events) {</div>
<div class="line">            <span class="keywordflow">if</span> (event.type == Event::START) {</div>
<div class="line">                <span class="comment">// Add edge to active set</span></div>
<div class="line">                <span class="keyword">auto</span> [iter, inserted] = active_edges.insert(event.edge_id);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Check intersections with neighbors</span></div>
<div class="line">                <span class="keywordflow">if</span> (iter != active_edges.begin()) {</div>
<div class="line">                    <span class="keyword">auto</span> prev = std::prev(iter);</div>
<div class="line">                    checkAndAddIntersection(*prev, event.edge_id, </div>
<div class="line">                                          intersections, edges);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> next = std::next(iter);</div>
<div class="line">                <span class="keywordflow">if</span> (next != active_edges.end()) {</div>
<div class="line">                    checkAndAddIntersection(event.edge_id, *next,</div>
<div class="line">                                          intersections, edges);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event.type == Event::END) {</div>
<div class="line">                <span class="comment">// Remove edge from active set</span></div>
<div class="line">                <span class="keyword">auto</span> iter = active_edges.find(event.edge_id);</div>
<div class="line">                <span class="keywordflow">if</span> (iter != active_edges.end()) {</div>
<div class="line">                    <span class="comment">// Check if neighbors now intersect</span></div>
<div class="line">                    <span class="keyword">auto</span> prev = (iter != active_edges.begin()) ? </div>
<div class="line">                               std::prev(iter) : active_edges.end();</div>
<div class="line">                    <span class="keyword">auto</span> next = std::next(iter);</div>
<div class="line">                    </div>
<div class="line">                    active_edges.erase(iter);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (prev != active_edges.end() &amp;&amp; next != active_edges.end()) {</div>
<div class="line">                        checkAndAddIntersection(*prev, *next,</div>
<div class="line">                                              intersections, edges);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;Edge&gt; edges_storage;</div>
<div class="line">    <span class="keywordtype">double</span> current_sweep_x;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> compareEdgesByY(<span class="keywordtype">int</span> edge_a, <span class="keywordtype">int</span> edge_b) {</div>
<div class="line">        <span class="keywordtype">double</span> y_a = edges_storage[edge_a].y_at_x(current_sweep_x);</div>
<div class="line">        <span class="keywordtype">double</span> y_b = edges_storage[edge_b].y_at_x(current_sweep_x);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (std::abs(y_a - y_b) &gt; 1e-10) <span class="keywordflow">return</span> y_a &lt; y_b;</div>
<div class="line">        <span class="keywordflow">return</span> edge_a &lt; edge_b;  <span class="comment">// Tie-breaking</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> checkAndAddIntersection(<span class="keywordtype">int</span> edge1_id, <span class="keywordtype">int</span> edge2_id,</div>
<div class="line">                                std::vector&lt;Intersection&gt;&amp; intersections,</div>
<div class="line">                                <span class="keyword">const</span> std::vector&lt;Edge&gt;&amp; edges) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge1 = edges[edge1_id];</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge2 = edges[edge2_id];</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> intersection = segmentIntersection(</div>
<div class="line">            edge1.start, edge1.end,</div>
<div class="line">            edge2.start, edge2.end</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (intersection.exists) {</div>
<div class="line">            intersections.push_back({</div>
<div class="line">                intersection.point,</div>
<div class="line">                edge1.polygon_id, edge1.edge_index,</div>
<div class="line">                edge2.polygon_id, edge2.edge_index,</div>
<div class="line">                intersection.is_proper</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md10"></a>
Python Implementation</h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>EdgeIntersectionDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Optimized edge intersection detection for EDA layouts.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>detect_intersections(polygons, include_touching=False):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Detect all edge intersections in polygon collection.</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            polygons: List of Polygon objects</span></div>
<div class="line"><span class="stringliteral">            include_touching: Include endpoint touching as intersections</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        Returns:</span></div>
<div class="line"><span class="stringliteral">            List of intersection dictionaries</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        intersections = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Use spatial indexing for efficiency</span></div>
<div class="line">        spatial_index = SpatialIndex()</div>
<div class="line">        edge_data = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Index all edges</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            edges = polygon.edges</div>
<div class="line">            <span class="keywordflow">for</span> edge_id, (start, end) <span class="keywordflow">in</span> enumerate(edges):</div>
<div class="line">                bbox = BoundingBox.from_points([start, end])</div>
<div class="line">                edge_info = {</div>
<div class="line">                    <span class="stringliteral">&#39;polygon_id&#39;</span>: poly_id,</div>
<div class="line">                    <span class="stringliteral">&#39;edge_id&#39;</span>: edge_id,</div>
<div class="line">                    <span class="stringliteral">&#39;start&#39;</span>: start,</div>
<div class="line">                    <span class="stringliteral">&#39;end&#39;</span>: end,</div>
<div class="line">                    <span class="stringliteral">&#39;bbox&#39;</span>: bbox</div>
<div class="line">                }</div>
<div class="line">                spatial_index.insert(bbox, len(edge_data))</div>
<div class="line">                edge_data.append(edge_info)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check intersections</span></div>
<div class="line">        checked_pairs = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> i, edge1 <span class="keywordflow">in</span> enumerate(edge_data):</div>
<div class="line">            <span class="comment"># Query nearby edges</span></div>
<div class="line">            candidates = spatial_index.query(edge1[<span class="stringliteral">&#39;bbox&#39;</span>])</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> candidates:</div>
<div class="line">                <span class="keywordflow">if</span> i &gt;= j:  <span class="comment"># Avoid duplicate checks</span></div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                    </div>
<div class="line">                edge2 = edge_data[j]</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Skip adjacent edges in same polygon</span></div>
<div class="line">                <span class="keywordflow">if</span> (edge1[<span class="stringliteral">&#39;polygon_id&#39;</span>] == edge2[<span class="stringliteral">&#39;polygon_id&#39;</span>] <span class="keywordflow">and</span> </div>
<div class="line">                    abs(edge1[<span class="stringliteral">&#39;edge_id&#39;</span>] - edge2[<span class="stringliteral">&#39;edge_id&#39;</span>]) &lt;= 1):</div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                </div>
<div class="line">                pair = (i, j)</div>
<div class="line">                <span class="keywordflow">if</span> pair <span class="keywordflow">in</span> checked_pairs:</div>
<div class="line">                    <span class="keywordflow">continue</span></div>
<div class="line">                checked_pairs.add(pair)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Check for intersection</span></div>
<div class="line">                intersection = EdgeIntersectionDetector._segment_intersection(</div>
<div class="line">                    edge1[<span class="stringliteral">&#39;start&#39;</span>], edge1[<span class="stringliteral">&#39;end&#39;</span>],</div>
<div class="line">                    edge2[<span class="stringliteral">&#39;start&#39;</span>], edge2[<span class="stringliteral">&#39;end&#39;</span>]</div>
<div class="line">                )</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;exists&#39;</span>]:</div>
<div class="line">                    <span class="keywordflow">if</span> include_touching <span class="keywordflow">or</span> intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]:</div>
<div class="line">                        intersections.append({</div>
<div class="line">                            <span class="stringliteral">&#39;point&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;polygon1_id&#39;</span>: edge1[<span class="stringliteral">&#39;polygon_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;edge1_id&#39;</span>: edge1[<span class="stringliteral">&#39;edge_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;polygon2_id&#39;</span>: edge2[<span class="stringliteral">&#39;polygon_id&#39;</span>], </div>
<div class="line">                            <span class="stringliteral">&#39;edge2_id&#39;</span>: edge2[<span class="stringliteral">&#39;edge_id&#39;</span>],</div>
<div class="line">                            <span class="stringliteral">&#39;is_proper&#39;</span>: intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]</div>
<div class="line">                        })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>_segment_intersection(p1, p2, p3, p4):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Calculate intersection between two line segments.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Direction vectors</span></div>
<div class="line">        d1 = (p2[0] - p1[0], p2[1] - p1[1])</div>
<div class="line">        d2 = (p4[0] - p3[0], p4[1] - p3[1])</div>
<div class="line">        d3 = (p1[0] - p3[0], p1[1] - p3[1])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Cross products for determinant</span></div>
<div class="line">        denominator = d1[0] * d2[1] - d1[1] * d2[0]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check for parallel lines</span></div>
<div class="line">        <span class="keywordflow">if</span> abs(denominator) &lt; 1e-10:</div>
<div class="line">            <span class="keywordflow">return</span> {<span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">False</span>, <span class="stringliteral">&#39;point&#39;</span>: <span class="keywordtype">None</span>, <span class="stringliteral">&#39;is_proper&#39;</span>: <span class="keyword">False</span>}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Calculate parameters</span></div>
<div class="line">        t = (d2[0] * d3[1] - d2[1] * d3[0]) / denominator</div>
<div class="line">        s = (d1[0] * d3[1] - d1[1] * d3[0]) / denominator</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check if intersection is within both segments</span></div>
<div class="line">        <span class="keywordflow">if</span> 0.0 &lt;= t &lt;= 1.0 <span class="keywordflow">and</span> 0.0 &lt;= s &lt;= 1.0:</div>
<div class="line">            intersection_point = (</div>
<div class="line">                p1[0] + t * d1[0],</div>
<div class="line">                p1[1] + t * d1[1]</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Determine if it&#39;s a proper intersection</span></div>
<div class="line">            epsilon = 1e-10</div>
<div class="line">            is_proper = (epsilon &lt; t &lt; 1.0 - epsilon <span class="keywordflow">and</span> </div>
<div class="line">                        epsilon &lt; s &lt; 1.0 - epsilon)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> {</div>
<div class="line">                <span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">True</span>,</div>
<div class="line">                <span class="stringliteral">&#39;point&#39;</span>: intersection_point,</div>
<div class="line">                <span class="stringliteral">&#39;is_proper&#39;</span>: is_proper</div>
<div class="line">            }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&#39;exists&#39;</span>: <span class="keyword">False</span>, <span class="stringliteral">&#39;point&#39;</span>: <span class="keywordtype">None</span>, <span class="stringliteral">&#39;is_proper&#39;</span>: <span class="keyword">False</span>}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md12"></a>
Complexity Analysis</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Time Complexity Comparison</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Algorithm   </th><th class="markdownTableHeadNone">Preprocessing   </th><th class="markdownTableHeadNone">Detection   </th><th class="markdownTableHeadNone">Total   </th><th class="markdownTableHeadNone">Space    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Brute Force   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sweep Line   </td><td class="markdownTableBodyNone">O(nm log(nm))   </td><td class="markdownTableBodyNone">O((nm+k)log(nm))   </td><td class="markdownTableBodyNone">O((nm+k)log(nm))   </td><td class="markdownTableBodyNone">O(nm)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Spatial Index   </td><td class="markdownTableBodyNone">O(nm log(nm))   </td><td class="markdownTableBodyNone">O(nm log(nm) + k)   </td><td class="markdownTableBodyNone">O(nm log(nm) + k)   </td><td class="markdownTableBodyNone">O(nm)   </td></tr>
</table>
<p>Where:</p><ul>
<li><code>n</code> = number of polygons</li>
<li><code>m</code> = average edges per polygon</li>
<li><code>k</code> = number of intersections found</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Performance Benchmarks</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>benchmark_intersection_algorithms():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compare performance of different intersection algorithms.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    polygon_counts = [10, 50, 100, 500]</div>
<div class="line">    edge_counts = [4, 8, 16, 32]  <span class="comment"># Average edges per polygon</span></div>
<div class="line">    </div>
<div class="line">    results = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> n_polys <span class="keywordflow">in</span> polygon_counts:</div>
<div class="line">        <span class="keywordflow">for</span> avg_edges <span class="keywordflow">in</span> edge_counts:</div>
<div class="line">            test_polygons = generate_complex_layout(n_polys, avg_edges)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Brute force method</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            bf_detector = BruteForceDetector()</div>
<div class="line">            bf_results = bf_detector.detect_intersections(test_polygons)</div>
<div class="line">            bf_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Sweep line method</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            sl_detector = SweepLineDetector()</div>
<div class="line">            sl_results = sl_detector.detect_intersections(test_polygons)</div>
<div class="line">            sl_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Spatial index method</span></div>
<div class="line">            start = time.perf_counter()</div>
<div class="line">            si_detector = EdgeIntersectionDetector()</div>
<div class="line">            si_results = si_detector.detect_intersections(test_polygons)</div>
<div class="line">            si_time = time.perf_counter() - start</div>
<div class="line">            </div>
<div class="line">            key = f<span class="stringliteral">&quot;{n_polys}p_{avg_edges}e&quot;</span></div>
<div class="line">            results[key] = {</div>
<div class="line">                <span class="stringliteral">&#39;brute_force&#39;</span>: bf_time,</div>
<div class="line">                <span class="stringliteral">&#39;sweep_line&#39;</span>: sl_time,</div>
<div class="line">                <span class="stringliteral">&#39;spatial_index&#39;</span>: si_time,</div>
<div class="line">                <span class="stringliteral">&#39;intersections_found&#39;</span>: len(si_results)</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            print(f<span class="stringliteral">&quot;{key}: BF={bf_time:.3f}s, SL={sl_time:.3f}s, SI={si_time:.3f}s&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md16"></a>
Interactive Tutorial</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Tutorial 1: Basic Intersection Detection</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create test case with known intersections</span></div>
<div class="line">polygons = [</div>
<div class="line">    <span class="comment"># Self-intersecting bowtie polygon</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([</div>
<div class="line">        (0, 0), (4, 4), (4, 0), (0, 4)  <span class="comment"># Creates X-shape intersection</span></div>
<div class="line">    ]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Two overlapping rectangles</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(5, 1, 3, 2),  <span class="comment"># Rectangle 1</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(6, 0, 3, 3),  <span class="comment"># Rectangle 2 - overlaps with Rectangle 1</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Triangle intersecting rectangle</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([</div>
<div class="line">        (10, 0), (13, 0), (11.5, 3)   <span class="comment"># Triangle</span></div>
<div class="line">    ]),</div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(11, 1, 2, 1),   <span class="comment"># Rectangle intersecting triangle</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">detector = zlayout.EdgeIntersectionDetector()</div>
<div class="line">intersections = detector.detect_intersections(polygons)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Found {len(intersections)} edge intersections:&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> i, intersection <span class="keywordflow">in</span> enumerate(intersections):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Intersection {i+1}:&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Location: ({intersection[&#39;point&#39;][0]:.2f}, {intersection[&#39;point&#39;][1]:.2f})&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Between: Polygon {intersection[&#39;polygon1_id&#39;]} edge {intersection[&#39;edge1_id&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;           Polygon {intersection[&#39;polygon2_id&#39;]} edge {intersection[&#39;edge2_id&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Type: {&#39;Proper crossing&#39; if intersection[&#39;is_proper&#39;] else &#39;Endpoint touching&#39;}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_polygon_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_polygon.html">zlayout::geometry::Polygon</a></div><div class="ttdoc">Polygon class supporting both convex and concave polygons.</div><div class="ttdef"><b>Definition</b> <a href="polygon_8hpp_source.html#l00025">polygon.hpp:25</a></div></div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_rectangle_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout::geometry::Rectangle</a></div><div class="ttdoc">Axis-aligned rectangle for bounding boxes and simple EDA components.</div><div class="ttdef"><b>Definition</b> <a href="rectangle_8hpp_source.html#l00026">rectangle.hpp:26</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Tutorial 2: Self-Intersection Validation</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>validate_polygon_integrity(polygon):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Check if a polygon has self-intersections.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Create single-polygon list for intersection detection</span></div>
<div class="line">    result = detector.detect_intersections([polygon])</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Filter for self-intersections only</span></div>
<div class="line">    self_intersections = [</div>
<div class="line">        inter <span class="keywordflow">for</span> inter <span class="keywordflow">in</span> result </div>
<div class="line">        <span class="keywordflow">if</span> inter[<span class="stringliteral">&#39;polygon1_id&#39;</span>] == inter[<span class="stringliteral">&#39;polygon2_id&#39;</span>]</div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> self_intersections:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Polygon has {len(self_intersections)} self-intersections:&quot;</span>)</div>
<div class="line">        <span class="keywordflow">for</span> inter <span class="keywordflow">in</span> self_intersections:</div>
<div class="line">            print(f<span class="stringliteral">&quot;  Edge {inter[&#39;edge1_id&#39;]} intersects edge {inter[&#39;edge2_id&#39;]}&quot;</span>)</div>
<div class="line">            print(f<span class="stringliteral">&quot;  At point: ({inter[&#39;point&#39;][0]:.3f}, {inter[&#39;point&#39;][1]:.3f})&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        print(<span class="stringliteral">&quot;Polygon is valid (no self-intersections)&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Test various polygon types</span></div>
<div class="line">test_cases = [</div>
<div class="line">    <span class="comment"># Valid simple polygon</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (4, 0), (4, 3), (0, 3)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Self-intersecting bowtie</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (2, 2), (2, 0), (0, 2)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Complex valid polygon</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 0), (3, 0), (4, 1), (3, 3), (1, 4), (0, 2)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Figure-8 shape (self-intersecting)</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(0, 1), (1, 2), (2, 1), (3, 2), (4, 1), (3, 0), (2, 1), (1, 0)])</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> i, polygon <span class="keywordflow">in</span> enumerate(test_cases):</div>
<div class="line">    print(f<span class="stringliteral">&quot;\n=== Test Case {i+1} ===&quot;</span>)</div>
<div class="line">    is_valid = validate_polygon_integrity(polygon)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md20"></a>
Real-world Applications</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
1. Layout Verification</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>LayoutVerifier:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self.detector = EdgeIntersectionDetector()</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>comprehensive_intersection_check(self, layout):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Perform comprehensive intersection analysis.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        report = {</div>
<div class="line">            <span class="stringliteral">&#39;self_intersections&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;component_overlaps&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;critical_intersections&#39;</span>: [],</div>
<div class="line">            <span class="stringliteral">&#39;total_intersections&#39;</span>: 0</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Get all intersections</span></div>
<div class="line">        all_intersections = self.detector.detect_intersections(</div>
<div class="line">            layout.components, include_touching=<span class="keyword">True</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        report[<span class="stringliteral">&#39;total_intersections&#39;</span>] = len(all_intersections)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> intersection <span class="keywordflow">in</span> all_intersections:</div>
<div class="line">            <span class="comment"># Categorize intersection type</span></div>
<div class="line">            <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>] == intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]:</div>
<div class="line">                <span class="comment"># Self-intersection</span></div>
<div class="line">                report[<span class="stringliteral">&#39;self_intersections&#39;</span>].append(intersection)</div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># Component overlap</span></div>
<div class="line">                component1 = layout.components[intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>]]</div>
<div class="line">                component2 = layout.components[intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]]</div>
<div class="line">                </div>
<div class="line">                overlap_info = {</div>
<div class="line">                    <span class="stringliteral">&#39;intersection&#39;</span>: intersection,</div>
<div class="line">                    <span class="stringliteral">&#39;component1_name&#39;</span>: component1.name,</div>
<div class="line">                    <span class="stringliteral">&#39;component2_name&#39;</span>: component2.name,</div>
<div class="line">                    <span class="stringliteral">&#39;component1_layer&#39;</span>: component1.layer,</div>
<div class="line">                    <span class="stringliteral">&#39;component2_layer&#39;</span>: component2.layer</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Check if it&#39;s a critical intersection</span></div>
<div class="line">                <span class="keywordflow">if</span> (component1.layer == component2.layer <span class="keywordflow">and</span> </div>
<div class="line">                    intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]):</div>
<div class="line">                    report[<span class="stringliteral">&#39;critical_intersections&#39;</span>].append(overlap_info)</div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    report[<span class="stringliteral">&#39;component_overlaps&#39;</span>].append(overlap_info)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> report</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>generate_fix_suggestions(self, intersection_report):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Generate suggestions for fixing intersections.&quot;&quot;&quot;</span></div>
<div class="line">        suggestions = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Self-intersection fixes</span></div>
<div class="line">        <span class="keywordflow">for</span> self_inter <span class="keywordflow">in</span> intersection_report[<span class="stringliteral">&#39;self_intersections&#39;</span>]:</div>
<div class="line">            suggestions.append({</div>
<div class="line">                <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;self_intersection&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;critical&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;message&#39;</span>: f<span class="stringliteral">&quot;Polygon has self-intersecting edges. Consider simplifying geometry.&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;location&#39;</span>: self_inter[<span class="stringliteral">&#39;point&#39;</span>]</div>
<div class="line">            })</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Critical overlap fixes</span></div>
<div class="line">        <span class="keywordflow">for</span> critical <span class="keywordflow">in</span> intersection_report[<span class="stringliteral">&#39;critical_intersections&#39;</span>]:</div>
<div class="line">            suggestions.append({</div>
<div class="line">                <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;component_overlap&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;high&#39;</span>, </div>
<div class="line">                <span class="stringliteral">&#39;message&#39;</span>: f<span class="stringliteral">&quot;Components &#39;{critical[&#39;component1_name&#39;]}&#39; and &quot;</span></div>
<div class="line">                          f<span class="stringliteral">&quot;&#39;{critical[&#39;component2_name&#39;]}&#39; overlap on same layer&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;suggestion&#39;</span>: <span class="stringliteral">&quot;Adjust component positions or modify routing&quot;</span></div>
<div class="line">            })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> suggestions</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
2. Manufacturing Constraint Checking</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>check_manufacturing_constraints(layout, process_rules):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Check for intersections that violate manufacturing rules.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    violations = []</div>
<div class="line">    intersections = detector.detect_intersections(layout.components)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> intersection <span class="keywordflow">in</span> intersections:</div>
<div class="line">        comp1 = layout.components[intersection[<span class="stringliteral">&#39;polygon1_id&#39;</span>]]</div>
<div class="line">        comp2 = layout.components[intersection[<span class="stringliteral">&#39;polygon2_id&#39;</span>]]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check same-layer intersections</span></div>
<div class="line">        <span class="keywordflow">if</span> comp1.layer == comp2.layer:</div>
<div class="line">            layer_rules = process_rules.get(comp1.layer, {})</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> intersection[<span class="stringliteral">&#39;is_proper&#39;</span>]:</div>
<div class="line">                <span class="comment"># Proper intersection on same layer is always violation</span></div>
<div class="line">                violations.append({</div>
<div class="line">                    <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;same_layer_overlap&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;error&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;layer&#39;</span>: comp1.layer,</div>
<div class="line">                    <span class="stringliteral">&#39;location&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>],</div>
<div class="line">                    <span class="stringliteral">&#39;components&#39;</span>: [comp1.name, comp2.name]</div>
<div class="line">                })</div>
<div class="line">            </div>
<div class="line">        <span class="comment"># Check inter-layer violations</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># Some layer combinations are not allowed to intersect</span></div>
<div class="line">            forbidden_combinations = process_rules.get(<span class="stringliteral">&#39;forbidden_intersections&#39;</span>, [])</div>
<div class="line">            layer_pair = tuple(sorted([comp1.layer, comp2.layer]))</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> layer_pair <span class="keywordflow">in</span> forbidden_combinations:</div>
<div class="line">                violations.append({</div>
<div class="line">                    <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;forbidden_layer_intersection&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;severity&#39;</span>: <span class="stringliteral">&#39;warning&#39;</span>,</div>
<div class="line">                    <span class="stringliteral">&#39;layers&#39;</span>: layer_pair,</div>
<div class="line">                    <span class="stringliteral">&#39;location&#39;</span>: intersection[<span class="stringliteral">&#39;point&#39;</span>]</div>
<div class="line">                })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> violations</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md24"></a>
Advanced Optimizations</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Bentley-Ottmann Algorithm</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>BentleyOttmannDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Optimal O((n+k) log n) intersection detection.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>detect_intersections_optimal(self, polygons):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Bentley-Ottmann sweep line algorithm.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        events = []</div>
<div class="line">        edges = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Create initial events</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            poly_edges = polygon.edges</div>
<div class="line">            <span class="keywordflow">for</span> edge_id, (start, end) <span class="keywordflow">in</span> enumerate(poly_edges):</div>
<div class="line">                <span class="comment"># Ensure left-to-right ordering</span></div>
<div class="line">                <span class="keywordflow">if</span> start[0] &gt; end[0] <span class="keywordflow">or</span> (start[0] == end[0] <span class="keywordflow">and</span> start[1] &gt; end[1]):</div>
<div class="line">                    start, end = end, start</div>
<div class="line">                </div>
<div class="line">                edge_data = {</div>
<div class="line">                    <span class="stringliteral">&#39;id&#39;</span>: len(edges),</div>
<div class="line">                    <span class="stringliteral">&#39;polygon_id&#39;</span>: poly_id,</div>
<div class="line">                    <span class="stringliteral">&#39;edge_id&#39;</span>: edge_id,</div>
<div class="line">                    <span class="stringliteral">&#39;start&#39;</span>: start,</div>
<div class="line">                    <span class="stringliteral">&#39;end&#39;</span>: end</div>
<div class="line">                }</div>
<div class="line">                edges.append(edge_data)</div>
<div class="line">                </div>
<div class="line">                events.append(Event(start[0], <span class="stringliteral">&#39;start&#39;</span>, len(edges) - 1))</div>
<div class="line">                events.append(Event(end[0], <span class="stringliteral">&#39;end&#39;</span>, len(edges) - 1))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Sort events</span></div>
<div class="line">        events.sort(key=<span class="keyword">lambda</span> e: (e.x, e.type == <span class="stringliteral">&#39;end&#39;</span>))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Sweep line state</span></div>
<div class="line">        active_edges = BalancedBST()  <span class="comment"># Y-ordered active edges</span></div>
<div class="line">        intersections = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> event <span class="keywordflow">in</span> events:</div>
<div class="line">            <span class="keywordflow">if</span> event.type == <span class="stringliteral">&#39;start&#39;</span>:</div>
<div class="line">                edge = edges[event.edge_id]</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Insert edge and find neighbors</span></div>
<div class="line">                node = active_edges.insert(edge)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Check intersections with neighbors</span></div>
<div class="line">                <span class="keywordflow">if</span> node.predecessor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edges[node.predecessor.edge_id], edge, intersections</div>
<div class="line">                    )</div>
<div class="line">                <span class="keywordflow">if</span> node.successor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edge, edges[node.successor.edge_id], intersections</div>
<div class="line">                    )</div>
<div class="line">                    </div>
<div class="line">            <span class="keywordflow">elif</span> event.type == <span class="stringliteral">&#39;end&#39;</span>:</div>
<div class="line">                edge = edges[event.edge_id]</div>
<div class="line">                node = active_edges.find(edge)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Check if predecessor and successor now intersect</span></div>
<div class="line">                <span class="keywordflow">if</span> node.predecessor <span class="keywordflow">and</span> node.successor:</div>
<div class="line">                    self._check_intersection(</div>
<div class="line">                        edges[node.predecessor.edge_id],</div>
<div class="line">                        edges[node.successor.edge_id], </div>
<div class="line">                        intersections</div>
<div class="line">                    )</div>
<div class="line">                </div>
<div class="line">                active_edges.delete(node)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> intersections</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md27"></a>
Performance Summary</h1>
<p>Edge intersection detection characteristics:</p>
<p><b>Algorithm Selection:</b></p><ul>
<li><b>Brute Force</b>: Use for &lt;100 edges total</li>
<li>**Spatial Index**: Best general-purpose algorithm</li>
<li>**Sweep Line**: Optimal for sparse intersections</li>
<li>**Bentley-Ottmann**: Best theoretical complexity</li>
</ul>
<p>**Performance Scaling:**</p><ul>
<li>Small datasets (&lt;1K edges): All algorithms acceptable</li>
<li>Medium datasets (1K-10K edges): Spatial indexing recommended</li>
<li>Large datasets (&gt;10K edges): Sweep line or Bentley-Ottmann</li>
</ul>
<p><b>Memory Requirements:</b></p><ul>
<li>Brute force: O(1) working memory</li>
<li>Spatial index: O(n) for index structure</li>
<li>Sweep line: O(n) for event queue and active set</li>
</ul>
<p><b>Practical Considerations:</b></p><ol type="1">
<li>Spatial indexing has best average-case performance</li>
<li>Sweep line excels when intersection density is low <br  />
</li>
<li>Numerical precision critical for robust results</li>
<li>Early termination possible for validation use cases</li>
</ol>
<p>The algorithm is fundamental to geometric validation, enabling reliable detection of layout errors and ensuring geometric integrity in EDA workflows. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
