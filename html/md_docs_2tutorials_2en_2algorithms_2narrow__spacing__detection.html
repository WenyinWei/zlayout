<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: Narrow Spacing Detection Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2en_2algorithms_2narrow__spacing__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Narrow Spacing Detection Algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md28"></a> <em>Manufacturing Constraints Validation for EDA Layouts</em></p>
<h1><a class="anchor" id="autotoc_md29"></a>
Overview</h1>
<p>Narrow spacing detection identifies regions where geometric features are closer than manufacturing tolerances allow. This algorithm is essential for design rule checking (DRC) and ensuring fabrication reliability in advanced semiconductor processes.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Problem Definition</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Manufacturing Challenges</h2>
<ul>
<li><b>Etching Resolution</b>: Features too close may merge during etching</li>
<li><b>Lithography Limits</b>: Optical resolution constraints in photolithography <br  />
</li>
<li><b>Process Variations</b>: Manufacturing tolerances require minimum separations</li>
<li><b>Electrical Issues</b>: Parasitic coupling and crosstalk</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
Mathematical Foundation</h2>
<p>For two line segments or polygon edges: </p><div class="fragment"><div class="line">minimum_distance = min(point_to_line_distance(p1, segment2), </div>
<div class="line">                      point_to_line_distance(p2, segment1),</div>
<div class="line">                      segment_to_segment_distance(segment1, segment2))</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md34"></a>
Core Algorithm</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Approach 1: Brute Force O(n²)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>NarrowSpacingDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>SpacingViolation {</div>
<div class="line">        Point point1, point2;</div>
<div class="line">        <span class="keywordtype">double</span> distance;</div>
<div class="line">        <span class="keywordtype">int</span> polygon1_id, polygon2_id;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;SpacingViolation&gt; detectNarrowSpacing(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Polygon&gt;&amp; polygons,</div>
<div class="line">        <span class="keywordtype">double</span> min_spacing = 0.1</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;SpacingViolation&gt; violations;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check between different polygons</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; polygons.size(); ++i) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i + 1; j &lt; polygons.size(); ++j) {</div>
<div class="line">                <span class="keyword">auto</span> poly_violations = checkPolygonPair(</div>
<div class="line">                    polygons[i], polygons[j], min_spacing, i, j</div>
<div class="line">                );</div>
<div class="line">                violations.insert(violations.end(), </div>
<div class="line">                                poly_violations.begin(), </div>
<div class="line">                                poly_violations.end());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;SpacingViolation&gt; checkPolygonPair(</div>
<div class="line">        <span class="keyword">const</span> Polygon&amp; poly1, <span class="keyword">const</span> Polygon&amp; poly2,</div>
<div class="line">        <span class="keywordtype">double</span> min_spacing, <span class="keywordtype">int</span> id1, <span class="keywordtype">int</span> id2</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;SpacingViolation&gt; violations;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> edges1 = poly1.edges();</div>
<div class="line">        <span class="keyword">auto</span> edges2 = poly2.edges();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge1 : edges1) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge2 : edges2) {</div>
<div class="line">                <span class="keywordtype">double</span> dist = segmentToSegmentDistance(</div>
<div class="line">                    edge1.first, edge1.second,</div>
<div class="line">                    edge2.first, edge2.second</div>
<div class="line">                );</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (dist &lt; min_spacing) {</div>
<div class="line">                    <span class="keyword">auto</span> closest_points = findClosestPoints(edge1, edge2);</div>
<div class="line">                    violations.push_back({</div>
<div class="line">                        closest_points.first,</div>
<div class="line">                        closest_points.second,</div>
<div class="line">                        dist, id1, id2</div>
<div class="line">                    });</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> segmentToSegmentDistance(</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2,</div>
<div class="line">        <span class="keyword">const</span> Point&amp; p3, <span class="keyword">const</span> Point&amp; p4</div>
<div class="line">    ) {</div>
<div class="line">        <span class="comment">// Implementation using closest point algorithms</span></div>
<div class="line">        <span class="keywordflow">return</span> calculateMinimumDistance(p1, p2, p3, p4);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Approach 2: Spatial Index Optimization O(n log n)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>OptimizedSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.spatial_index = <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds)</div>
<div class="line">        self.polygon_cache = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>detect_narrow_spacing(self, polygons, min_spacing=0.1):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Optimized spacing detection using spatial indexing.&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Build spatial index</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            expanded_bbox = bbox.expand(min_spacing)</div>
<div class="line">            self.spatial_index.insert(expanded_bbox, poly_id)</div>
<div class="line">            self.polygon_cache[poly_id] = polygon</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check only nearby polygon pairs</span></div>
<div class="line">        checked_pairs = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            search_bbox = bbox.expand(min_spacing * 1.5)</div>
<div class="line">            </div>
<div class="line">            nearby_ids = self.spatial_index.query_range(search_bbox)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> nearby_id <span class="keywordflow">in</span> nearby_ids:</div>
<div class="line">                <span class="keywordflow">if</span> nearby_id != poly_id:</div>
<div class="line">                    pair = tuple(sorted([poly_id, nearby_id]))</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> pair <span class="keywordflow">not</span> <span class="keywordflow">in</span> checked_pairs:</div>
<div class="line">                        checked_pairs.add(pair)</div>
<div class="line">                        </div>
<div class="line">                        nearby_polygon = self.polygon_cache[nearby_id]</div>
<div class="line">                        pair_violations = self._check_polygon_pair(</div>
<div class="line">                            polygon, nearby_polygon, </div>
<div class="line">                            min_spacing, poly_id, nearby_id</div>
<div class="line">                        )</div>
<div class="line">                        violations.extend(pair_violations)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_check_polygon_pair(self, poly1, poly2, min_spacing, id1, id2):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Check spacing between two polygons.&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Quick bounding box check</span></div>
<div class="line">        bbox1 = poly1.bounding_box()</div>
<div class="line">        bbox2 = poly2.bounding_box()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> bbox1.distance_to(bbox2) &gt;= min_spacing:</div>
<div class="line">            <span class="keywordflow">return</span> violations  <span class="comment"># Too far apart</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Detailed edge-to-edge checking</span></div>
<div class="line">        <span class="keywordflow">for</span> edge1 <span class="keywordflow">in</span> poly1.edges:</div>
<div class="line">            <span class="keywordflow">for</span> edge2 <span class="keywordflow">in</span> poly2.edges:</div>
<div class="line">                dist = self._segment_distance(edge1, edge2)</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> dist &lt; min_spacing:</div>
<div class="line">                    closest_pts = self._closest_points_on_segments(edge1, edge2)</div>
<div class="line">                    violations.append({</div>
<div class="line">                        <span class="stringliteral">&#39;point1&#39;</span>: closest_pts[0],</div>
<div class="line">                        <span class="stringliteral">&#39;point2&#39;</span>: closest_pts[1], </div>
<div class="line">                        <span class="stringliteral">&#39;distance&#39;</span>: dist,</div>
<div class="line">                        <span class="stringliteral">&#39;polygon1_id&#39;</span>: id1,</div>
<div class="line">                        <span class="stringliteral">&#39;polygon2_id&#39;</span>: id2</div>
<div class="line">                    })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
<div class="ttc" id="aclasszlayout_1_1spatial_1_1_quad_tree_html"><div class="ttname"><a href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout::spatial::QuadTree</a></div><div class="ttdoc">Quadtree spatial index for efficient range and intersection queries.</div><div class="ttdef"><b>Definition</b> <a href="quadtree_8hpp_source.html#l00120">quadtree.hpp:120</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md38"></a>
Complexity Analysis</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Time Complexity Comparison</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method   </th><th class="markdownTableHeadNone">Preprocessing   </th><th class="markdownTableHeadNone">Query   </th><th class="markdownTableHeadNone">Overall   </th><th class="markdownTableHeadNone">Space    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Brute Force   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(n²m²)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Spatial Index   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(k log n)   </td><td class="markdownTableBodyNone">O(n log n + km²)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">R-tree   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n log n + km²)   </td><td class="markdownTableBodyNone">O(n)   </td></tr>
</table>
<p>Where:</p><ul>
<li><code>n</code> = number of polygons</li>
<li><code>m</code> = average edges per polygon <br  />
</li>
<li><code>k</code> = average nearby polygons per query</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
Performance Scaling</h2>
<div class="fragment"><div class="line"><span class="comment"># Benchmark different approaches</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>benchmark_spacing_detection():</div>
<div class="line">    polygon_counts = [10, 50, 100, 500, 1000]</div>
<div class="line">    </div>
<div class="line">    results = {</div>
<div class="line">        <span class="stringliteral">&#39;brute_force&#39;</span>: [],</div>
<div class="line">        <span class="stringliteral">&#39;spatial_index&#39;</span>: [],</div>
<div class="line">        <span class="stringliteral">&#39;rtree&#39;</span>: []</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> n_polygons <span class="keywordflow">in</span> polygon_counts:</div>
<div class="line">        <span class="comment"># Generate test data</span></div>
<div class="line">        test_polygons = generate_test_layout(n_polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Brute force method</span></div>
<div class="line">        start = time.perf_counter()</div>
<div class="line">        bf_detector = BruteForceDetector()</div>
<div class="line">        bf_results = bf_detector.detect_narrow_spacing(test_polygons, 0.1)</div>
<div class="line">        bf_time = time.perf_counter() - start</div>
<div class="line">        results[<span class="stringliteral">&#39;brute_force&#39;</span>].append(bf_time)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Spatial index method</span></div>
<div class="line">        start = time.perf_counter()</div>
<div class="line">        si_detector = OptimizedSpacingDetector(world_bounds)</div>
<div class="line">        si_results = si_detector.detect_narrow_spacing(test_polygons, 0.1)</div>
<div class="line">        si_time = time.perf_counter() - start</div>
<div class="line">        results[<span class="stringliteral">&#39;spatial_index&#39;</span>].append(si_time)</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;N={n_polygons}: BF={bf_time:.3f}s, SI={si_time:.3f}s, &quot;</span></div>
<div class="line">              f<span class="stringliteral">&quot;Speedup={bf_time/si_time:.1f}x&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Expected output shows dramatic speedup for large datasets</span></div>
<div class="line">benchmark_results = benchmark_spacing_detection()</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md42"></a>
Interactive Tutorial</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Tutorial 1: Basic Spacing Check</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create test layout with spacing violations</span></div>
<div class="line">components = [</div>
<div class="line">    <span class="comment"># Two rectangles very close together</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 0, 10, 5),    <span class="comment"># Component 1</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(10.05, 0, 10, 5), <span class="comment"># Component 2 - only 0.05 apart!</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Another pair with proper spacing</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 10, 8, 4),     <span class="comment"># Component 3  </span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(10, 10, 8, 4),    <span class="comment"># Component 4 - 2.0 apart</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">detector = zlayout.NarrowSpacingDetector()</div>
<div class="line">violations = detector.detect_narrow_spacing(</div>
<div class="line">    components, </div>
<div class="line">    min_spacing=0.1  <span class="comment"># 100nm minimum spacing</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Found {len(violations)} spacing violations&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> i, violation <span class="keywordflow">in</span> enumerate(violations):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Violation {i+1}: {violation[&#39;distance&#39;]:.3f} &lt; 0.1&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Between polygons {violation[&#39;polygon1_id&#39;]} and {violation[&#39;polygon2_id&#39;]}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_rectangle_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout::geometry::Rectangle</a></div><div class="ttdoc">Axis-aligned rectangle for bounding boxes and simple EDA components.</div><div class="ttdef"><b>Definition</b> <a href="rectangle_8hpp_source.html#l00026">rectangle.hpp:26</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md44"></a>
Tutorial 2: Process Node Validation</h2>
<div class="fragment"><div class="line"><span class="comment"># Different process nodes have different spacing requirements</span></div>
<div class="line">process_spacing_rules = {</div>
<div class="line">    <span class="stringliteral">&quot;28nm&quot;</span>: 0.028,  <span class="comment"># 28nm minimum spacing</span></div>
<div class="line">    <span class="stringliteral">&quot;14nm&quot;</span>: 0.014,  <span class="comment"># 14nm minimum spacing</span></div>
<div class="line">    <span class="stringliteral">&quot;7nm&quot;</span>:  0.007,  <span class="comment"># 7nm minimum spacing</span></div>
<div class="line">    <span class="stringliteral">&quot;3nm&quot;</span>:  0.003,  <span class="comment"># 3nm minimum spacing</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>validate_process_node(layout, process_node):</div>
<div class="line">    min_spacing = process_spacing_rules[process_node]</div>
<div class="line">    </div>
<div class="line">    violations = detector.detect_narrow_spacing(</div>
<div class="line">        layout.components, </div>
<div class="line">        min_spacing=min_spacing</div>
<div class="line">    )</div>
<div class="line">    </div>
<div class="line">    critical_violations = [</div>
<div class="line">        v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> violations </div>
<div class="line">        <span class="keywordflow">if</span> v[<span class="stringliteral">&#39;distance&#39;</span>] &lt; min_spacing * 0.8  <span class="comment"># Less than 80% of minimum</span></div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">        <span class="stringliteral">&#39;total_violations&#39;</span>: len(violations),</div>
<div class="line">        <span class="stringliteral">&#39;critical_violations&#39;</span>: len(critical_violations),</div>
<div class="line">        <span class="stringliteral">&#39;pass&#39;</span>: len(violations) == 0,</div>
<div class="line">        <span class="stringliteral">&#39;min_distance_found&#39;</span>: min([v[<span class="stringliteral">&#39;distance&#39;</span>] <span class="keywordflow">for</span> v <span class="keywordflow">in</span> violations]) <span class="keywordflow">if</span> violations <span class="keywordflow">else</span> float(<span class="stringliteral">&#39;inf&#39;</span>)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Test across different process nodes</span></div>
<div class="line">test_layout = generate_cpu_layout()</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> process <span class="keywordflow">in</span> [<span class="stringliteral">&quot;28nm&quot;</span>, <span class="stringliteral">&quot;14nm&quot;</span>, <span class="stringliteral">&quot;7nm&quot;</span>, <span class="stringliteral">&quot;3nm&quot;</span>]:</div>
<div class="line">    result = validate_process_node(test_layout, process)</div>
<div class="line">    status = <span class="stringliteral">&quot;PASS&quot;</span> <span class="keywordflow">if</span> result[<span class="stringliteral">&#39;pass&#39;</span>] <span class="keywordflow">else</span> <span class="stringliteral">&quot;FAIL&quot;</span></div>
<div class="line">    </div>
<div class="line">    print(f<span class="stringliteral">&quot;{process} Process: {status}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Violations: {result[&#39;total_violations&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Critical: {result[&#39;critical_violations&#39;]}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;  Min distance: {result[&#39;min_distance_found&#39;]:.4f}&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md46"></a>
Real-world Applications</h1>
<h2><a class="anchor" id="autotoc_md47"></a>
1. Advanced Process DRC</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>AdvancedDRCChecker:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, process_rules):</div>
<div class="line">        self.rules = process_rules</div>
<div class="line">        self.detectors = {}</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>comprehensive_spacing_check(self, layout):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Multi-layer spacing validation.&quot;&quot;&quot;</span></div>
<div class="line">        all_violations = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Different layers have different spacing rules</span></div>
<div class="line">        layer_rules = {</div>
<div class="line">            <span class="stringliteral">&#39;metal1&#39;</span>: self.rules[<span class="stringliteral">&#39;metal1_spacing&#39;</span>],</div>
<div class="line">            <span class="stringliteral">&#39;metal2&#39;</span>: self.rules[<span class="stringliteral">&#39;metal2_spacing&#39;</span>], </div>
<div class="line">            <span class="stringliteral">&#39;via&#39;</span>: self.rules[<span class="stringliteral">&#39;via_spacing&#39;</span>],</div>
<div class="line">            <span class="stringliteral">&#39;poly&#39;</span>: self.rules[<span class="stringliteral">&#39;poly_spacing&#39;</span>]</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> layer_name, min_spacing <span class="keywordflow">in</span> layer_rules.items():</div>
<div class="line">            layer_components = layout.get_layer_components(layer_name)</div>
<div class="line">            </div>
<div class="line">            violations = self.detect_narrow_spacing(</div>
<div class="line">                layer_components, min_spacing</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Additional checks for special cases</span></div>
<div class="line">            <span class="keywordflow">if</span> layer_name == <span class="stringliteral">&#39;via&#39;</span>:</div>
<div class="line">                violations.extend(self._check_via_to_via_spacing(</div>
<div class="line">                    layer_components, min_spacing * 1.2</div>
<div class="line">                ))</div>
<div class="line">            </div>
<div class="line">            all_violations[layer_name] = violations</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> all_violations</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
2. Parasitic Extraction Guidance</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>analyze_coupling_risk(spacing_violations, frequency_mhz=1000):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Analyze electrical coupling risk from spacing violations.&quot;&quot;&quot;</span></div>
<div class="line">    coupling_analysis = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> violation <span class="keywordflow">in</span> spacing_violations:</div>
<div class="line">        <span class="comment"># Calculate coupling capacitance</span></div>
<div class="line">        distance = violation[<span class="stringliteral">&#39;distance&#39;</span>]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Simple parallel plate capacitor model</span></div>
<div class="line">        <span class="comment"># C = ε₀ × εᵣ × A / d</span></div>
<div class="line">        coupling_capacitance = calculate_coupling_capacitance(</div>
<div class="line">            distance, </div>
<div class="line">            conductor_width=1.0,  <span class="comment"># Assume 1μm width</span></div>
<div class="line">            dielectric_constant=3.9  <span class="comment"># SiO2</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Estimate coupling noise</span></div>
<div class="line">        coupling_noise_mv = estimate_coupling_noise(</div>
<div class="line">            coupling_capacitance, frequency_mhz</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        risk_level = <span class="stringliteral">&quot;HIGH&quot;</span> <span class="keywordflow">if</span> coupling_noise_mv &gt; 50 <span class="keywordflow">else</span> \</div>
<div class="line">                    <span class="stringliteral">&quot;MEDIUM&quot;</span> <span class="keywordflow">if</span> coupling_noise_mv &gt; 10 <span class="keywordflow">else</span> <span class="stringliteral">&quot;LOW&quot;</span></div>
<div class="line">        </div>
<div class="line">        coupling_analysis.append({</div>
<div class="line">            <span class="stringliteral">&#39;violation&#39;</span>: violation,</div>
<div class="line">            <span class="stringliteral">&#39;coupling_capacitance_ff&#39;</span>: coupling_capacitance * 1e15,</div>
<div class="line">            <span class="stringliteral">&#39;coupling_noise_mv&#39;</span>: coupling_noise_mv,</div>
<div class="line">            <span class="stringliteral">&#39;risk_level&#39;</span>: risk_level</div>
<div class="line">        })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> coupling_analysis</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md50"></a>
Advanced Optimizations</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
GPU Acceleration for Large Datasets</h2>
<div class="fragment"><div class="line"><span class="comment"># For extremely large layouts (millions of polygons)</span></div>
<div class="line"><span class="keyword">class </span>GPUSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, use_cuda=True):</div>
<div class="line">        self.use_cuda = use_cuda <span class="keywordflow">and</span> cuda_available()</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>detect_narrow_spacing_gpu(self, polygons, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;GPU-accelerated spacing detection.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.use_cuda:</div>
<div class="line">            <span class="keywordflow">return</span> self.fallback_cpu_detection(polygons, min_spacing)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Convert polygons to GPU-friendly format</span></div>
<div class="line">        gpu_polygons = self._prepare_gpu_data(polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Launch CUDA kernels for parallel distance computation</span></div>
<div class="line">        violations = self._cuda_spacing_kernel(gpu_polygons, min_spacing)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> self._format_violations(violations)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_cuda_spacing_kernel(self, gpu_data, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;CUDA kernel for parallel distance computation.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Pseudo-CUDA code</span></div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        __global__ void spacing_kernel(</span></div>
<div class="line"><span class="stringliteral">            float* polygon_data, </span></div>
<div class="line"><span class="stringliteral">            int num_polygons,</span></div>
<div class="line"><span class="stringliteral">            float min_spacing,</span></div>
<div class="line"><span class="stringliteral">            int* violations_out</span></div>
<div class="line"><span class="stringliteral">        ) {</span></div>
<div class="line"><span class="stringliteral">            int idx = blockIdx.x * blockDim.x + threadIdx.x;</span></div>
<div class="line"><span class="stringliteral">            // Parallel distance computation...</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">pass</span>  <span class="comment"># Implementation details</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
Memory-Efficient Streaming</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>StreamingSpacingDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, chunk_size=1000):</div>
<div class="line">        self.chunk_size = chunk_size</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">def </span>detect_large_layout(self, layout_iterator, min_spacing):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Process layouts too large to fit in memory.&quot;&quot;&quot;</span></div>
<div class="line">        violations = []</div>
<div class="line">        polygon_chunks = []</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Process in chunks</span></div>
<div class="line">        <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> self._chunk_iterator(layout_iterator, self.chunk_size):</div>
<div class="line">            chunk_violations = self._process_chunk(chunk, min_spacing)</div>
<div class="line">            violations.extend(chunk_violations)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Keep recent chunks for cross-chunk checking</span></div>
<div class="line">            polygon_chunks.append(chunk)</div>
<div class="line">            <span class="keywordflow">if</span> len(polygon_chunks) &gt; 3:  <span class="comment"># Keep 3 chunks in memory</span></div>
<div class="line">                polygon_chunks.pop(0)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Check interactions between chunks</span></div>
<div class="line">            <span class="keywordflow">if</span> len(polygon_chunks) &gt; 1:</div>
<div class="line">                cross_violations = self._check_chunk_boundaries(</div>
<div class="line">                    polygon_chunks[-2], polygon_chunks[-1], min_spacing</div>
<div class="line">                )</div>
<div class="line">                violations.extend(cross_violations)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> violations</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md54"></a>
Performance Summary</h1>
<p>Narrow spacing detection performance characteristics:</p>
<p><b>Algorithm Complexity:</b></p><ul>
<li><b>Brute Force</b>: O(n²m²) - prohibitive for large layouts</li>
<li><b>Spatial Index</b>: O(n log n + km²) - practical for production</li>
<li><b>GPU Accelerated</b>: O(n log n) with massive parallelism</li>
</ul>
<p><b>Memory Usage:</b></p><ul>
<li><b>Basic</b>: O(n) for polygon storage</li>
<li><b>Spatial Index</b>: O(n) additional for index structure</li>
<li><b>Streaming</b>: O(chunk_size) for arbitrarily large layouts</li>
</ul>
<p><b>Practical Performance:</b></p><ul>
<li>1K polygons: ~10ms (spatial index)</li>
<li>10K polygons: ~100ms (spatial index) <br  />
</li>
<li>100K polygons: ~1s (spatial index)</li>
<li>1M+ polygons: GPU acceleration recommended</li>
</ul>
<p><b>Optimization Guidelines:</b></p><ol type="1">
<li>Use spatial indexing for &gt;100 polygons</li>
<li>Consider bounding box pre-filtering</li>
<li>GPU acceleration for &gt;100K polygons</li>
<li>Streaming for memory-constrained environments</li>
</ol>
<p>The algorithm is essential for modern EDA flows, enabling reliable manufacturing at advanced process nodes while maintaining reasonable computational performance. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
