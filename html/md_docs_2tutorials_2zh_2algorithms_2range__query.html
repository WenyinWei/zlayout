<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: 范围查询操作</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2zh_2algorithms_2range__query.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">范围查询操作</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md221"></a> <em>多边形重叠检测的高效空间搜索</em></p>
<h1><a class="anchor" id="autotoc_md222"></a>
概述</h1>
<p>范围查询操作查找与给定矩形区域重叠的所有多边形。这是EDA工具中碰撞检测、区域选择和邻近分析的基础操作。范围查询的效率直接影响交互性能。</p>
<h1><a class="anchor" id="autotoc_md223"></a>
问题定义</h1>
<h2><a class="anchor" id="autotoc_md224"></a>
查询类型</h2>
<ul>
<li>**点查询**：查找包含特定点的多边形</li>
<li>**矩形查询**：查找与矩形区域重叠的多边形 <br  />
</li>
<li>**圆形查询**：查找在圆形半径内的多边形</li>
<li>**多边形查询**：查找与任意多边形重叠的多边形</li>
</ul>
<h2><a class="anchor" id="autotoc_md225"></a>
数学基础</h2>
<p>对于多边形P和查询矩形Q： </p><div class="fragment"><div class="line">重叠(P, Q) = true 当：</div>
<div class="line">  包围盒(P) ∩ 包围盒(Q) ≠ ∅ 且</div>
<div class="line">  详细相交(P, Q) = true</div>
</div><!-- fragment --><p>两阶段过滤：</p><ol type="1">
<li>**粗筛选**：包围盒相交测试（快速）</li>
<li>**细筛选**：详细几何相交（精确）</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md227"></a>
数据结构比较</h1>
<h2><a class="anchor" id="autotoc_md228"></a>
1. 四叉树实现</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>QuadTree {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>Node {</div>
<div class="line">        Rectangle bounds;</div>
<div class="line">        std::vector&lt;int&gt; polygon_ids;</div>
<div class="line">        std::array&lt;std::unique_ptr&lt;Node&gt;, 4&gt; children;</div>
<div class="line">        <span class="keywordtype">bool</span> is_leaf = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> MAX_POLYGONS = 10;</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> MAX_DEPTH = 12;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;Node&gt; root;</div>
<div class="line">    std::vector&lt;Polygon&gt; polygons;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    QuadTree(<span class="keyword">const</span> Rectangle&amp; world_bounds) {</div>
<div class="line">        root = std::make_unique&lt;Node&gt;();</div>
<div class="line">        root-&gt;bounds = world_bounds;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keyword">const</span> Polygon&amp; polygon) {</div>
<div class="line">        <span class="keywordtype">int</span> poly_id = polygons.size();</div>
<div class="line">        polygons.push_back(polygon);</div>
<div class="line">        insert_recursive(root.get(), poly_id, 0);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;int&gt; range_query(<span class="keyword">const</span> Rectangle&amp; query_rect)<span class="keyword"> const </span>{</div>
<div class="line">        std::vector&lt;int&gt; results;</div>
<div class="line">        range_query_recursive(root.get(), query_rect, results);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 细筛选：详细相交测试</span></div>
<div class="line">        std::vector&lt;int&gt; filtered_results;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> poly_id : results) {</div>
<div class="line">            <span class="keywordflow">if</span> (polygons[poly_id].intersects(query_rect)) {</div>
<div class="line">                filtered_results.push_back(poly_id);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> filtered_results;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> insert_recursive(Node* node, <span class="keywordtype">int</span> poly_id, <span class="keywordtype">int</span> depth) {</div>
<div class="line">        <span class="keywordflow">if</span> (node-&gt;is_leaf) {</div>
<div class="line">            node-&gt;polygon_ids.push_back(poly_id);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 必要时分裂</span></div>
<div class="line">            <span class="keywordflow">if</span> (node-&gt;polygon_ids.size() &gt; Node::MAX_POLYGONS &amp;&amp; </div>
<div class="line">                depth &lt; Node::MAX_DEPTH) {</div>
<div class="line">                split_node(node, depth);</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// 插入到适当的子节点</span></div>
<div class="line">            Rectangle poly_bbox = polygons[poly_id].bounding_box();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (node-&gt;children[i]-&gt;bounds.intersects(poly_bbox)) {</div>
<div class="line">                    insert_recursive(node-&gt;children[i].get(), poly_id, depth + 1);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> range_query_recursive(<span class="keyword">const</span> Node* node, <span class="keyword">const</span> Rectangle&amp; query_rect,</div>
<div class="line">                              std::vector&lt;int&gt;&amp; results)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!node-&gt;bounds.intersects(query_rect)) {</div>
<div class="line">            <span class="keywordflow">return</span>;  <span class="comment">// 与节点边界无相交</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (node-&gt;is_leaf) {</div>
<div class="line">            <span class="comment">// 添加此叶节点中的所有多边形（粗筛选）</span></div>
<div class="line">            results.insert(results.end(), </div>
<div class="line">                          node-&gt;polygon_ids.begin(), </div>
<div class="line">                          node-&gt;polygon_ids.end());</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// 递归查询子节点</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; child : node-&gt;children) {</div>
<div class="line">                <span class="keywordflow">if</span> (child) {</div>
<div class="line">                    range_query_recursive(child.get(), query_rect, results);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> split_node(Node* node, <span class="keywordtype">int</span> depth) {</div>
<div class="line">        node-&gt;is_leaf = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 创建四个象限</span></div>
<div class="line">        <span class="keywordtype">double</span> mid_x = (node-&gt;bounds.min_x + node-&gt;bounds.max_x) / 2.0;</div>
<div class="line">        <span class="keywordtype">double</span> mid_y = (node-&gt;bounds.min_y + node-&gt;bounds.max_y) / 2.0;</div>
<div class="line">        </div>
<div class="line">        node-&gt;children[0] = std::make_unique&lt;Node&gt;();  <span class="comment">// 西北</span></div>
<div class="line">        node-&gt;children[0]-&gt;bounds = Rectangle(</div>
<div class="line">            node-&gt;bounds.min_x, mid_y, mid_x, node-&gt;bounds.max_y);</div>
<div class="line">            </div>
<div class="line">        node-&gt;children[1] = std::make_unique&lt;Node&gt;();  <span class="comment">// 东北</span></div>
<div class="line">        node-&gt;children[1]-&gt;bounds = Rectangle(</div>
<div class="line">            mid_x, mid_y, node-&gt;bounds.max_x, node-&gt;bounds.max_y);</div>
<div class="line">            </div>
<div class="line">        node-&gt;children[2] = std::make_unique&lt;Node&gt;();  <span class="comment">// 西南</span></div>
<div class="line">        node-&gt;children[2]-&gt;bounds = Rectangle(</div>
<div class="line">            node-&gt;bounds.min_x, node-&gt;bounds.min_y, mid_x, mid_y);</div>
<div class="line">            </div>
<div class="line">        node-&gt;children[3] = std::make_unique&lt;Node&gt;();  <span class="comment">// 东南</span></div>
<div class="line">        node-&gt;children[3]-&gt;bounds = Rectangle(</div>
<div class="line">            mid_x, node-&gt;bounds.min_y, node-&gt;bounds.max_x, mid_y);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 重新分配多边形</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> poly_id : node-&gt;polygon_ids) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">                Rectangle poly_bbox = polygons[poly_id].bounding_box();</div>
<div class="line">                <span class="keywordflow">if</span> (node-&gt;children[i]-&gt;bounds.intersects(poly_bbox)) {</div>
<div class="line">                    insert_recursive(node-&gt;children[i].get(), poly_id, depth + 1);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        node-&gt;polygon_ids.clear();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md229"></a>
2. R树实现</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RTree {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>Node {</div>
<div class="line">        Rectangle bounding_box;</div>
<div class="line">        std::vector&lt;std::pair&lt;Rectangle, int&gt;&gt; entries;  <span class="comment">// (包围盒, 多边形ID)</span></div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;Node&gt;&gt; children;</div>
<div class="line">        <span class="keywordtype">bool</span> is_leaf = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> MIN_ENTRIES = 2;</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> MAX_ENTRIES = 8;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;Node&gt; root;</div>
<div class="line">    std::vector&lt;Polygon&gt; polygons;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RTree() {</div>
<div class="line">        root = std::make_unique&lt;Node&gt;();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keyword">const</span> Polygon&amp; polygon) {</div>
<div class="line">        <span class="keywordtype">int</span> poly_id = polygons.size();</div>
<div class="line">        polygons.push_back(polygon);</div>
<div class="line">        </div>
<div class="line">        Rectangle poly_bbox = polygon.bounding_box();</div>
<div class="line">        insert_recursive(root.get(), poly_bbox, poly_id);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;int&gt; range_query(<span class="keyword">const</span> Rectangle&amp; query_rect)<span class="keyword"> const </span>{</div>
<div class="line">        std::vector&lt;int&gt; results;</div>
<div class="line">        range_query_recursive(root.get(), query_rect, results);</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> insert_recursive(Node* node, <span class="keyword">const</span> Rectangle&amp; bbox, <span class="keywordtype">int</span> poly_id) {</div>
<div class="line">        <span class="keywordflow">if</span> (node-&gt;is_leaf) {</div>
<div class="line">            node-&gt;entries.emplace_back(bbox, poly_id);</div>
<div class="line">            node-&gt;bounding_box = node-&gt;bounding_box.union_with(bbox);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (node-&gt;entries.size() &gt; Node::MAX_ENTRIES) {</div>
<div class="line">                split_node(node);</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// 选择面积扩张最小的子树</span></div>
<div class="line">            <span class="keywordtype">int</span> best_child = choose_subtree(node, bbox);</div>
<div class="line">            insert_recursive(node-&gt;children[best_child].get(), bbox, poly_id);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 更新包围盒</span></div>
<div class="line">            node-&gt;bounding_box = node-&gt;bounding_box.union_with(bbox);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> range_query_recursive(<span class="keyword">const</span> Node* node, <span class="keyword">const</span> Rectangle&amp; query_rect,</div>
<div class="line">                              std::vector&lt;int&gt;&amp; results)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!node-&gt;bounding_box.intersects(query_rect)) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (node-&gt;is_leaf) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [bbox, poly_id] : node-&gt;entries) {</div>
<div class="line">                <span class="keywordflow">if</span> (bbox.intersects(query_rect)) {</div>
<div class="line">                    <span class="comment">// 详细相交测试</span></div>
<div class="line">                    <span class="keywordflow">if</span> (polygons[poly_id].intersects(query_rect)) {</div>
<div class="line">                        results.push_back(poly_id);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; child : node-&gt;children) {</div>
<div class="line">                range_query_recursive(child.get(), query_rect, results);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> choose_subtree(Node* node, <span class="keyword">const</span> Rectangle&amp; bbox) {</div>
<div class="line">        <span class="keywordtype">int</span> best_child = 0;</div>
<div class="line">        <span class="keywordtype">double</span> min_enlargement = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; node-&gt;children.size(); ++i) {</div>
<div class="line">            Rectangle union_bbox = node-&gt;children[i]-&gt;bounding_box.union_with(bbox);</div>
<div class="line">            <span class="keywordtype">double</span> enlargement = union_bbox.area() - </div>
<div class="line">                               node-&gt;children[i]-&gt;bounding_box.area();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (enlargement &lt; min_enlargement) {</div>
<div class="line">                min_enlargement = enlargement;</div>
<div class="line">                best_child = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> best_child;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md230"></a>
3. Z序空间哈希</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ZOrderIndex {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>ZOrderEntry {</div>
<div class="line">        uint64_t z_value;</div>
<div class="line">        <span class="keywordtype">int</span> polygon_id;</div>
<div class="line">        Rectangle bbox;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> ZOrderEntry&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> z_value &lt; other.z_value;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;ZOrderEntry&gt; entries;</div>
<div class="line">    std::vector&lt;Polygon&gt; polygons;</div>
<div class="line">    Rectangle world_bounds;</div>
<div class="line">    <span class="keywordtype">bool</span> is_sorted = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ZOrderIndex(<span class="keyword">const</span> Rectangle&amp; bounds) : world_bounds(bounds) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keyword">const</span> Polygon&amp; polygon) {</div>
<div class="line">        <span class="keywordtype">int</span> poly_id = polygons.size();</div>
<div class="line">        polygons.push_back(polygon);</div>
<div class="line">        </div>
<div class="line">        Rectangle bbox = polygon.bounding_box();</div>
<div class="line">        uint64_t z_value = compute_z_order(bbox.center());</div>
<div class="line">        </div>
<div class="line">        entries.push_back({z_value, poly_id, bbox});</div>
<div class="line">        is_sorted = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;int&gt; range_query(<span class="keyword">const</span> Rectangle&amp; query_rect)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!is_sorted) {</div>
<div class="line">            std::sort(<span class="keyword">const_cast&lt;</span>std::vector&lt;ZOrderEntry&gt;&amp;<span class="keyword">&gt;</span>(entries).begin(),</div>
<div class="line">                     <span class="keyword">const_cast&lt;</span>std::vector&lt;ZOrderEntry&gt;&amp;<span class="keyword">&gt;</span>(entries).end());</div>
<div class="line">            <span class="keyword">const_cast&lt;</span>ZOrderIndex*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;is_sorted = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; results;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 计算查询矩形的Z序范围</span></div>
<div class="line">        <span class="keyword">auto</span> [z_min, z_max] = compute_z_range(query_rect);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 二分搜索范围</span></div>
<div class="line">        <span class="keyword">auto</span> lower = std::lower_bound(entries.begin(), entries.end(),</div>
<div class="line">                                    ZOrderEntry{z_min, -1, Rectangle()});</div>
<div class="line">        <span class="keyword">auto</span> upper = std::upper_bound(entries.begin(), entries.end(),</div>
<div class="line">                                    ZOrderEntry{z_max, -1, Rectangle()});</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 检查Z序范围内的候选项</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = lower; it != upper; ++it) {</div>
<div class="line">            <span class="keywordflow">if</span> (it-&gt;bbox.intersects(query_rect)) {</div>
<div class="line">                <span class="keywordflow">if</span> (polygons[it-&gt;polygon_id].intersects(query_rect)) {</div>
<div class="line">                    results.push_back(it-&gt;polygon_id);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    uint64_t compute_z_order(<span class="keyword">const</span> Point&amp; point)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">// 将坐标标准化到[0, 1]</span></div>
<div class="line">        <span class="keywordtype">double</span> norm_x = (point.x - world_bounds.min_x) / world_bounds.width();</div>
<div class="line">        <span class="keywordtype">double</span> norm_y = (point.y - world_bounds.min_y) / world_bounds.height();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 转换为整数坐标</span></div>
<div class="line">        uint32_t int_x = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(norm_x * UINT32_MAX);</div>
<div class="line">        uint32_t int_y = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(norm_y * UINT32_MAX);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 交错位以创建Z序值</span></div>
<div class="line">        <span class="keywordflow">return</span> interleave_bits(int_x, int_y);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t interleave_bits(uint32_t x, uint32_t y)<span class="keyword"> const </span>{</div>
<div class="line">        uint64_t result = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; ++i) {</div>
<div class="line">            result |= ((x &amp; (1ULL &lt;&lt; i)) &lt;&lt; i) | ((y &amp; (1ULL &lt;&lt; i)) &lt;&lt; (i + 1));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::pair&lt;uint64_t, uint64_t&gt; compute_z_range(<span class="keyword">const</span> Rectangle&amp; rect)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">// 简化：使用最小和最大角点</span></div>
<div class="line">        uint64_t z_min = compute_z_order(Point(rect.min_x, rect.min_y));</div>
<div class="line">        uint64_t z_max = compute_z_order(Point(rect.max_x, rect.max_y));</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {std::min(z_min, z_max), std::max(z_min, z_max)};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md232"></a>
性能分析</h1>
<h2><a class="anchor" id="autotoc_md233"></a>
复杂度比较</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">数据结构   </th><th class="markdownTableHeadNone">构建时间   </th><th class="markdownTableHeadNone">查询时间   </th><th class="markdownTableHeadNone">空间复杂度   </th><th class="markdownTableHeadNone">最佳用例    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">四叉树   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">均匀分布    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">R树   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">聚集矩形    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Z序   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">高维数据    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">混合索引   </td><td class="markdownTableBodyNone">O(n log n)   </td><td class="markdownTableBodyNone">O(log n + k)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">混合负载   </td></tr>
</table>
<p>其中：</p><ul>
<li><code>n</code> = 多边形数量</li>
<li><code>k</code> = 返回的结果数量</li>
</ul>
<h2><a class="anchor" id="autotoc_md234"></a>
Python基准测试框架</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RangeQueryBenchmark:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;范围查询算法的综合基准测试&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.world_bounds = world_bounds</div>
<div class="line">        self.algorithms = {</div>
<div class="line">            <span class="stringliteral">&#39;quadtree&#39;</span>: QuadTreeIndex(world_bounds),</div>
<div class="line">            <span class="stringliteral">&#39;rtree&#39;</span>: RTreeIndex(world_bounds),</div>
<div class="line">            <span class="stringliteral">&#39;zorder&#39;</span>: ZOrderIndex(world_bounds),</div>
<div class="line">            <span class="stringliteral">&#39;hybrid&#39;</span>: HybridIndex(world_bounds)</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>benchmark_range_queries(self, polygons, query_rects, num_trials=10):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;基准测试不同的范围查询算法&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        results = {}</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> algo_name, index <span class="keywordflow">in</span> self.algorithms.items():</div>
<div class="line">            print(f<span class="stringliteral">&quot;\n基准测试 {algo_name}...&quot;</span>)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 构建索引</span></div>
<div class="line">            build_start = time.perf_counter()</div>
<div class="line">            <span class="keywordflow">for</span> polygon <span class="keywordflow">in</span> polygons:</div>
<div class="line">                index.insert(polygon)</div>
<div class="line">            build_time = time.perf_counter() - build_start</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 查询性能</span></div>
<div class="line">            query_times = []</div>
<div class="line">            result_counts = []</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> trial <span class="keywordflow">in</span> range(num_trials):</div>
<div class="line">                <span class="keywordflow">for</span> query_rect <span class="keywordflow">in</span> query_rects:</div>
<div class="line">                    query_start = time.perf_counter()</div>
<div class="line">                    query_results = index.range_query(query_rect)</div>
<div class="line">                    query_time = time.perf_counter() - query_start</div>
<div class="line">                    </div>
<div class="line">                    query_times.append(query_time)</div>
<div class="line">                    result_counts.append(len(query_results))</div>
<div class="line">            </div>
<div class="line">            results[algo_name] = {</div>
<div class="line">                <span class="stringliteral">&#39;build_time&#39;</span>: build_time,</div>
<div class="line">                <span class="stringliteral">&#39;avg_query_time&#39;</span>: np.mean(query_times),</div>
<div class="line">                <span class="stringliteral">&#39;avg_results&#39;</span>: np.mean(result_counts),</div>
<div class="line">                <span class="stringliteral">&#39;memory_usage&#39;</span>: index.memory_usage()</div>
<div class="line">            }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>generate_test_scenarios(self, n_polygons):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;为综合评估生成不同的测试场景&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        scenarios = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 均匀随机分布</span></div>
<div class="line">        scenarios[<span class="stringliteral">&#39;uniform&#39;</span>] = self.generate_uniform_polygons(n_polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 聚集分布</span></div>
<div class="line">        scenarios[<span class="stringliteral">&#39;clustered&#39;</span>] = self.generate_clustered_polygons(n_polygons, n_clusters=10)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 真实EDA布局模式</span></div>
<div class="line">        scenarios[<span class="stringliteral">&#39;eda_pattern&#39;</span>] = self.generate_eda_layout(n_polygons)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> scenarios</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>generate_query_patterns(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;生成不同的查询模式用于测试&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        queries = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 小面积查询（世界面积的1%）</span></div>
<div class="line">        small_area = self.world_bounds.area() * 0.01</div>
<div class="line">        side_length = math.sqrt(small_area)</div>
<div class="line">        queries[<span class="stringliteral">&#39;small&#39;</span>] = [</div>
<div class="line">            Rectangle(x, y, side_length, side_length)</div>
<div class="line">            <span class="keywordflow">for</span> x, y <span class="keywordflow">in</span> self.random_points(100)</div>
<div class="line">        ]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 中等面积查询（世界面积的5%）</span></div>
<div class="line">        medium_area = self.world_bounds.area() * 0.05</div>
<div class="line">        side_length = math.sqrt(medium_area)</div>
<div class="line">        queries[<span class="stringliteral">&#39;medium&#39;</span>] = [</div>
<div class="line">            Rectangle(x, y, side_length, side_length)</div>
<div class="line">            <span class="keywordflow">for</span> x, y <span class="keywordflow">in</span> self.random_points(50)</div>
<div class="line">        ]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 大面积查询（世界面积的20%）</span></div>
<div class="line">        large_area = self.world_bounds.area() * 0.20</div>
<div class="line">        side_length = math.sqrt(large_area)</div>
<div class="line">        queries[<span class="stringliteral">&#39;large&#39;</span>] = [</div>
<div class="line">            Rectangle(x, y, side_length, side_length)</div>
<div class="line">            <span class="keywordflow">for</span> x, y <span class="keywordflow">in</span> self.random_points(20)</div>
<div class="line">        ]</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> queries</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 运行综合基准测试</span></div>
<div class="line"><span class="keyword">def </span>run_comprehensive_benchmark():</div>
<div class="line">    world_bounds = Rectangle(0, 0, 10000, 10000)</div>
<div class="line">    benchmark = RangeQueryBenchmark(world_bounds)</div>
<div class="line">    </div>
<div class="line">    polygon_counts = [1000, 5000, 10000, 50000]</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> n_polys <span class="keywordflow">in</span> polygon_counts:</div>
<div class="line">        print(f<span class="stringliteral">&quot;\n=== 测试 {n_polys} 个多边形 ===&quot;</span>)</div>
<div class="line">        </div>
<div class="line">        scenarios = benchmark.generate_test_scenarios(n_polys)</div>
<div class="line">        query_patterns = benchmark.generate_query_patterns()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> scenario_name, polygons <span class="keywordflow">in</span> scenarios.items():</div>
<div class="line">            print(f<span class="stringliteral">&quot;\n场景: {scenario_name}&quot;</span>)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> query_name, queries <span class="keywordflow">in</span> query_patterns.items():</div>
<div class="line">                print(f<span class="stringliteral">&quot;查询模式: {query_name}&quot;</span>)</div>
<div class="line">                </div>
<div class="line">                results = benchmark.benchmark_range_queries(polygons, queries)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># 打印结果表</span></div>
<div class="line">                print(f<span class="stringliteral">&quot;{&#39;算法&#39;:&lt;12} {&#39;构建(ms)&#39;:&lt;12} {&#39;查询(μs)&#39;:&lt;12} {&#39;结果数&#39;:&lt;10} {&#39;内存(MB)&#39;:&lt;12}&quot;</span>)</div>
<div class="line">                print(<span class="stringliteral">&quot;-&quot;</span> * 60)</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">for</span> algo, metrics <span class="keywordflow">in</span> results.items():</div>
<div class="line">                    print(f<span class="stringliteral">&quot;{algo:&lt;12} {metrics[&#39;build_time&#39;]*1000:&lt;12.1f} &quot;</span></div>
<div class="line">                          f<span class="stringliteral">&quot;{metrics[&#39;avg_query_time&#39;]*1e6:&lt;12.1f} &quot;</span></div>
<div class="line">                          f<span class="stringliteral">&quot;{metrics[&#39;avg_results&#39;]:&lt;10.1f} &quot;</span></div>
<div class="line">                          f<span class="stringliteral">&quot;{metrics[&#39;memory_usage&#39;]/1e6:&lt;12.1f}&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md236"></a>
交互式教程</h1>
<h2><a class="anchor" id="autotoc_md237"></a>
教程1：基础范围查询</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 创建包含各种多边形类型的测试布局</span></div>
<div class="line">world_bounds = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 0, 1000, 1000)</div>
<div class="line">index = <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 添加不同类型的组件</span></div>
<div class="line">components = [</div>
<div class="line">    <span class="comment"># 常规组件</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(100, 100, 50, 30),   <span class="comment"># 小矩形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(200, 150, 80, 60),   <span class="comment"># 中矩形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(400, 300, 120, 90),  <span class="comment"># 大矩形</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 三角形组件</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(500, 100), (600, 100), (550, 180)]),</div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(700, 200), (800, 220), (750, 300)]),</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 复杂多边形</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>([(50, 500), (150, 480), (180, 550), (120, 600), (30, 580)]),</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 构建空间索引</span></div>
<div class="line"><span class="keywordflow">for</span> component <span class="keywordflow">in</span> components:</div>
<div class="line">    index.insert(component)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 定义查询区域</span></div>
<div class="line">query_regions = [</div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(80, 80, 100, 100),    <span class="comment"># 与小矩形重叠</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(450, 250, 200, 200),  <span class="comment"># 与大矩形重叠</span></div>
<div class="line">    <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 450, 300, 200),    <span class="comment"># 与复杂多边形重叠</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 执行范围查询</span></div>
<div class="line"><span class="keywordflow">for</span> i, query_rect <span class="keywordflow">in</span> enumerate(query_regions):</div>
<div class="line">    print(f<span class="stringliteral">&quot;\n=== 查询 {i+1}: {query_rect} ===&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 查找重叠组件</span></div>
<div class="line">    overlapping_ids = index.range_query(query_rect)</div>
<div class="line">    </div>
<div class="line">    print(f<span class="stringliteral">&quot;发现 {len(overlapping_ids)} 个重叠组件:&quot;</span>)</div>
<div class="line">    <span class="keywordflow">for</span> comp_id <span class="keywordflow">in</span> overlapping_ids:</div>
<div class="line">        component = components[comp_id]</div>
<div class="line">        overlap_area = component.intersection_area(query_rect)</div>
<div class="line">        print(f<span class="stringliteral">&quot;  组件 {comp_id}: 重叠面积 = {overlap_area:.2f}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_polygon_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_polygon.html">zlayout::geometry::Polygon</a></div><div class="ttdoc">Polygon class supporting both convex and concave polygons.</div><div class="ttdef"><b>Definition</b> <a href="polygon_8hpp_source.html#l00025">polygon.hpp:25</a></div></div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_rectangle_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout::geometry::Rectangle</a></div><div class="ttdoc">Axis-aligned rectangle for bounding boxes and simple EDA components.</div><div class="ttdef"><b>Definition</b> <a href="rectangle_8hpp_source.html#l00026">rectangle.hpp:26</a></div></div>
<div class="ttc" id="aclasszlayout_1_1spatial_1_1_quad_tree_html"><div class="ttname"><a href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout::spatial::QuadTree</a></div><div class="ttdoc">Quadtree spatial index for efficient range and intersection queries.</div><div class="ttdef"><b>Definition</b> <a href="quadtree_8hpp_source.html#l00120">quadtree.hpp:120</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md238"></a>
教程2：性能比较</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>compare_index_performance():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;比较不同空间索引方法的性能&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 生成测试数据</span></div>
<div class="line">    world_bounds = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(0, 0, 5000, 5000)</div>
<div class="line">    n_polygons = 10000</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 创建不同的索引类型</span></div>
<div class="line">    indexes = {</div>
<div class="line">        <span class="stringliteral">&#39;四叉树&#39;</span>: <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds),</div>
<div class="line">        <span class="stringliteral">&#39;R树&#39;</span>: zlayout.RTree(world_bounds),</div>
<div class="line">        <span class="stringliteral">&#39;Z序&#39;</span>: zlayout.ZOrderIndex(world_bounds)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 生成测试多边形</span></div>
<div class="line">    polygons = generate_random_layout(n_polygons, world_bounds)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 构建索引并测量时间</span></div>
<div class="line">    build_times = {}</div>
<div class="line">    <span class="keywordflow">for</span> name, index <span class="keywordflow">in</span> indexes.items():</div>
<div class="line">        start_time = time.perf_counter()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> polygon <span class="keywordflow">in</span> polygons:</div>
<div class="line">            index.insert(polygon)</div>
<div class="line">            </div>
<div class="line">        build_times[name] = time.perf_counter() - start_time</div>
<div class="line">        print(f<span class="stringliteral">&quot;{name} 构建时间: {build_times[name]:.3f}s&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 生成查询矩形</span></div>
<div class="line">    query_rects = [</div>
<div class="line">        <a class="code hl_class" href="classzlayout_1_1geometry_1_1_rectangle.html">zlayout.Rectangle</a>(x, y, 100, 100)</div>
<div class="line">        <span class="keywordflow">for</span> x, y <span class="keywordflow">in</span> zip(</div>
<div class="line">            np.random.uniform(0, 4900, 1000),</div>
<div class="line">            np.random.uniform(0, 4900, 1000)</div>
<div class="line">        )</div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 测量查询性能</span></div>
<div class="line">    query_times = {}</div>
<div class="line">    <span class="keywordflow">for</span> name, index <span class="keywordflow">in</span> indexes.items():</div>
<div class="line">        times = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> query_rect <span class="keywordflow">in</span> query_rects:</div>
<div class="line">            start_time = time.perf_counter()</div>
<div class="line">            results = index.range_query(query_rect)</div>
<div class="line">            end_time = time.perf_counter()</div>
<div class="line">            </div>
<div class="line">            times.append(end_time - start_time)</div>
<div class="line">        </div>
<div class="line">        query_times[name] = {</div>
<div class="line">            <span class="stringliteral">&#39;avg&#39;</span>: np.mean(times),</div>
<div class="line">            <span class="stringliteral">&#39;median&#39;</span>: np.median(times),</div>
<div class="line">            <span class="stringliteral">&#39;p95&#39;</span>: np.percentile(times, 95)</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 打印比较表</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;\n{&#39;索引类型&#39;:&lt;12} {&#39;构建(s)&#39;:&lt;10} {&#39;平均查询(μs)&#39;:&lt;15} {&#39;P95查询(μs)&#39;:&lt;15}&quot;</span>)</div>
<div class="line">    print(<span class="stringliteral">&quot;-&quot;</span> * 55)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> name <span class="keywordflow">in</span> indexes.keys():</div>
<div class="line">        print(f<span class="stringliteral">&quot;{name:&lt;12} {build_times[name]:&lt;10.3f} &quot;</span></div>
<div class="line">              f<span class="stringliteral">&quot;{query_times[name][&#39;avg&#39;]*1e6:&lt;15.1f} &quot;</span></div>
<div class="line">              f<span class="stringliteral">&quot;{query_times[name][&#39;p95&#39;]*1e6:&lt;15.1f}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 运行性能比较</span></div>
<div class="line">compare_index_performance()</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md240"></a>
实际应用</h1>
<h2><a class="anchor" id="autotoc_md241"></a>
1. 交互式选择工具</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>InteractiveSelector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;EDA GUI的交互式多边形选择器&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, spatial_index):</div>
<div class="line">        self.index = spatial_index</div>
<div class="line">        self.selection_cache = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>select_in_region(self, selection_rect, selection_mode=&#39;replace&#39;):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;在矩形区域内选择多边形&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 对重复查询使用缓存</span></div>
<div class="line">        cache_key = (selection_rect.to_tuple(), selection_mode)</div>
<div class="line">        <span class="keywordflow">if</span> cache_key <span class="keywordflow">in</span> self.selection_cache:</div>
<div class="line">            <span class="keywordflow">return</span> self.selection_cache[cache_key]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 执行范围查询</span></div>
<div class="line">        candidates = self.index.range_query(selection_rect)</div>
<div class="line">        </div>
<div class="line">        selected_polygons = []</div>
<div class="line">        <span class="keywordflow">for</span> poly_id <span class="keywordflow">in</span> candidates:</div>
<div class="line">            polygon = self.index.get_polygon(poly_id)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 不同的选择条件</span></div>
<div class="line">            <span class="keywordflow">if</span> selection_mode == <span class="stringliteral">&#39;intersect&#39;</span>:</div>
<div class="line">                <span class="keywordflow">if</span> polygon.intersects(selection_rect):</div>
<div class="line">                    selected_polygons.append(poly_id)</div>
<div class="line">            <span class="keywordflow">elif</span> selection_mode == <span class="stringliteral">&#39;contain&#39;</span>:</div>
<div class="line">                <span class="keywordflow">if</span> selection_rect.contains(polygon):</div>
<div class="line">                    selected_polygons.append(poly_id)</div>
<div class="line">            <span class="keywordflow">elif</span> selection_mode == <span class="stringliteral">&#39;center&#39;</span>:</div>
<div class="line">                <span class="keywordflow">if</span> selection_rect.contains(polygon.center()):</div>
<div class="line">                    selected_polygons.append(poly_id)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 缓存结果</span></div>
<div class="line">        self.selection_cache[cache_key] = selected_polygons</div>
<div class="line">        <span class="keywordflow">return</span> selected_polygons</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>incremental_select(self, current_selection, new_rect, operation=&#39;add&#39;):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;基于操作增量更新选择&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        new_selection = self.select_in_region(new_rect)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> operation == <span class="stringliteral">&#39;add&#39;</span>:</div>
<div class="line">            <span class="keywordflow">return</span> list(set(current_selection) | set(new_selection))</div>
<div class="line">        <span class="keywordflow">elif</span> operation == <span class="stringliteral">&#39;subtract&#39;</span>:</div>
<div class="line">            <span class="keywordflow">return</span> list(set(current_selection) - set(new_selection))</div>
<div class="line">        <span class="keywordflow">elif</span> operation == <span class="stringliteral">&#39;intersect&#39;</span>:</div>
<div class="line">            <span class="keywordflow">return</span> list(set(current_selection) &amp; set(new_selection))</div>
<div class="line">        <span class="keywordflow">else</span>:  <span class="comment"># replace</span></div>
<div class="line">            <span class="keywordflow">return</span> new_selection</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md242"></a>
2. 碰撞检测系统</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>CollisionDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;组件放置的实时碰撞检测&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, spatial_index):</div>
<div class="line">        self.index = spatial_index</div>
<div class="line">        self.collision_threshold = 0.1  <span class="comment"># 最小间隙</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>check_placement(self, new_component, position):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;检查组件是否可以在位置上放置而不发生碰撞&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 将组件变换到新位置</span></div>
<div class="line">        positioned_component = new_component.translate(position)</div>
<div class="line">        component_bbox = positioned_component.bounding_box()</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 按碰撞阈值扩展包围盒</span></div>
<div class="line">        expanded_bbox = component_bbox.expand(self.collision_threshold)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 查找附近组件</span></div>
<div class="line">        nearby_components = self.index.range_query(expanded_bbox)</div>
<div class="line">        </div>
<div class="line">        collisions = []</div>
<div class="line">        <span class="keywordflow">for</span> comp_id <span class="keywordflow">in</span> nearby_components:</div>
<div class="line">            existing_component = self.index.get_polygon(comp_id)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 检查实际碰撞</span></div>
<div class="line">            distance = positioned_component.distance_to(existing_component)</div>
<div class="line">            <span class="keywordflow">if</span> distance &lt; self.collision_threshold:</div>
<div class="line">                collisions.append({</div>
<div class="line">                    <span class="stringliteral">&#39;component_id&#39;</span>: comp_id,</div>
<div class="line">                    <span class="stringliteral">&#39;distance&#39;</span>: distance,</div>
<div class="line">                    <span class="stringliteral">&#39;overlap_area&#39;</span>: positioned_component.intersection_area(existing_component)</div>
<div class="line">                })</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            <span class="stringliteral">&#39;can_place&#39;</span>: len(collisions) == 0,</div>
<div class="line">            <span class="stringliteral">&#39;collisions&#39;</span>: collisions,</div>
<div class="line">            <span class="stringliteral">&#39;collision_count&#39;</span>: len(collisions)</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>find_valid_positions(self, component, search_region, grid_spacing=10):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;在搜索区域内找到组件的所有有效位置&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        valid_positions = []</div>
<div class="line">        </div>
<div class="line">        x_positions = np.arange(search_region.min_x, search_region.max_x, grid_spacing)</div>
<div class="line">        y_positions = np.arange(search_region.min_y, search_region.max_y, grid_spacing)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> x <span class="keywordflow">in</span> x_positions:</div>
<div class="line">            <span class="keywordflow">for</span> y <span class="keywordflow">in</span> y_positions:</div>
<div class="line">                position = Point(x, y)</div>
<div class="line">                result = self.check_placement(component, position)</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> result[<span class="stringliteral">&#39;can_place&#39;</span>]:</div>
<div class="line">                    valid_positions.append(position)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> valid_positions</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md244"></a>
优化技术</h1>
<h2><a class="anchor" id="autotoc_md245"></a>
1. 查询结果缓存</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>CachedRangeQuery:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;具有智能缓存的范围查询&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, spatial_index, cache_size=1000):</div>
<div class="line">        self.index = spatial_index</div>
<div class="line">        self.cache = {}</div>
<div class="line">        self.cache_hits = 0</div>
<div class="line">        self.cache_misses = 0</div>
<div class="line">        self.max_cache_size = cache_size</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>range_query(self, query_rect, cache_enabled=True):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;具有可选缓存的范围查询&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> cache_enabled:</div>
<div class="line">            <span class="keywordflow">return</span> self.index.range_query(query_rect)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查缓存</span></div>
<div class="line">        cache_key = self._compute_cache_key(query_rect)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> cache_key <span class="keywordflow">in</span> self.cache:</div>
<div class="line">            self.cache_hits += 1</div>
<div class="line">            <span class="keywordflow">return</span> self.cache[cache_key]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 缓存未命中 - 执行实际查询</span></div>
<div class="line">        self.cache_misses += 1</div>
<div class="line">        results = self.index.range_query(query_rect)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 添加到缓存（必要时进行驱逐）</span></div>
<div class="line">        <span class="keywordflow">if</span> len(self.cache) &gt;= self.max_cache_size:</div>
<div class="line">            <span class="comment"># 简单的LRU驱逐</span></div>
<div class="line">            oldest_key = next(iter(self.cache))</div>
<div class="line">            del self.cache[oldest_key]</div>
<div class="line">        </div>
<div class="line">        self.cache[cache_key] = results</div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_compute_cache_key(self, query_rect):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;计算查询矩形的缓存键&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 量化坐标以减少类似查询的缓存未命中</span></div>
<div class="line">        quantum = 1.0</div>
<div class="line">        <span class="keywordflow">return</span> (</div>
<div class="line">            round(query_rect.min_x / quantum) * quantum,</div>
<div class="line">            round(query_rect.min_y / quantum) * quantum,</div>
<div class="line">            round(query_rect.width() / quantum) * quantum,</div>
<div class="line">            round(query_rect.height() / quantum) * quantum</div>
<div class="line">        )</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>get_cache_stats(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;获取缓存性能统计&quot;&quot;&quot;</span></div>
<div class="line">        total_queries = self.cache_hits + self.cache_misses</div>
<div class="line">        hit_rate = self.cache_hits / total_queries <span class="keywordflow">if</span> total_queries &gt; 0 <span class="keywordflow">else</span> 0</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            <span class="stringliteral">&#39;cache_hits&#39;</span>: self.cache_hits,</div>
<div class="line">            <span class="stringliteral">&#39;cache_misses&#39;</span>: self.cache_misses,</div>
<div class="line">            <span class="stringliteral">&#39;hit_rate&#39;</span>: hit_rate,</div>
<div class="line">            <span class="stringliteral">&#39;cache_size&#39;</span>: len(self.cache)</div>
<div class="line">        }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md246"></a>
2. 多线程范围查询</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParallelRangeQuery:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;大查询集的并行范围查询处理&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, spatial_index, num_threads=None):</div>
<div class="line">        self.index = spatial_index</div>
<div class="line">        self.num_threads = num_threads <span class="keywordflow">or</span> multiprocessing.cpu_count()</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>batch_range_query(self, query_rects):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;并行处理多个范围查询&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 将查询分成批次</span></div>
<div class="line">        batch_size = max(1, len(query_rects) // self.num_threads)</div>
<div class="line">        query_batches = [</div>
<div class="line">            query_rects[i:i + batch_size]</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0, len(query_rects), batch_size)</div>
<div class="line">        ]</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 并行处理批次</span></div>
<div class="line">        <span class="keyword">with</span> multiprocessing.Pool(self.num_threads) <span class="keyword">as</span> pool:</div>
<div class="line">            batch_results = pool.map(self._process_query_batch, query_batches)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 合并结果</span></div>
<div class="line">        all_results = []</div>
<div class="line">        <span class="keywordflow">for</span> batch_result <span class="keywordflow">in</span> batch_results:</div>
<div class="line">            all_results.extend(batch_result)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> all_results</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_process_query_batch(self, query_batch):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;在单线程中处理一批查询&quot;&quot;&quot;</span></div>
<div class="line">        batch_results = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> query_rect <span class="keywordflow">in</span> query_batch:</div>
<div class="line">            results = self.index.range_query(query_rect)</div>
<div class="line">            batch_results.append(results)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> batch_results</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md248"></a>
总结</h1>
<p>范围查询操作是EDA工具中空间数据处理的基础：</p>
<p><b>算法选择指南：</b></p><ul>
<li>**四叉树**：适用于均匀分布数据和交互式应用</li>
<li>**R树**：适用于聚集矩形数据和批量操作 <br  />
</li>
<li>**Z序**：适用于高维数据和并行处理</li>
<li>**混合索引**：结合多种方法优势，适用于多样化负载</li>
</ul>
<p><b>性能特征：</b></p><ul>
<li>所有算法都达到O(log n + k)查询复杂度</li>
<li>平衡结构的构建时间为O(n log n)</li>
<li>内存使用量与对象数量成线性关系O(n)</li>
</ul>
<p><b>优化策略：</b></p><ol type="1">
<li>根据数据分布选择适当的数据结构</li>
<li>为重复模式实现查询结果缓存</li>
<li>对批量查询使用并行处理</li>
<li>对复杂几何体应用两阶段过滤</li>
</ol>
<p>范围查询为交互式EDA工具和自动化布局验证系统提供了高效的空间分析支持。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
