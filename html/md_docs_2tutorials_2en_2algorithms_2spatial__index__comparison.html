<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: Spatial Index Comparison for EDA Applications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2en_2algorithms_2spatial__index__comparison.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Spatial Index Comparison for EDA Applications</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md127"></a> <em>Choosing the Right Data Structure for Large-Scale Layout Processing</em></p>
<h1><a class="anchor" id="autotoc_md128"></a>
Overview</h1>
<p>Spatial indexing is crucial for efficient geometric query processing in EDA tools. This comprehensive comparison analyzes four major spatial indexing approaches: QuadTree, R-tree, Z-order curves, and hybrid indexing, providing guidance for selecting the optimal structure based on data characteristics and query patterns.</p>
<h1><a class="anchor" id="autotoc_md129"></a>
Executive Summary</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Index Type   </th><th class="markdownTableHeadNone">Best For   </th><th class="markdownTableHeadNone">Strengths   </th><th class="markdownTableHeadNone">Weaknesses   </th><th class="markdownTableHeadNone">Time Complexity    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>QuadTree</b>   </td><td class="markdownTableBodyNone">Uniform point/rectangle data   </td><td class="markdownTableBodyNone">Simple, cache-friendly   </td><td class="markdownTableBodyNone">Poor for clustered data   </td><td class="markdownTableBodyNone">O(log n + k)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>R-tree</b>   </td><td class="markdownTableBodyNone">Clustered rectangles   </td><td class="markdownTableBodyNone">Minimal overlap   </td><td class="markdownTableBodyNone">Complex splitting   </td><td class="markdownTableBodyNone">O(log n + k)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Z-order</b>   </td><td class="markdownTableBodyNone">High-dimensional data   </td><td class="markdownTableBodyNone">Parallel-friendly   </td><td class="markdownTableBodyNone">Range query gaps   </td><td class="markdownTableBodyNone">O(log n + k)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Hybrid</b>   </td><td class="markdownTableBodyNone">Mixed workloads   </td><td class="markdownTableBodyNone">Adaptive   </td><td class="markdownTableBodyNone">Higher overhead   </td><td class="markdownTableBodyNone">O(log n + k)   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md131"></a>
1. QuadTree Analysis</h1>
<h2><a class="anchor" id="autotoc_md132"></a>
Algorithm Characteristics</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>QuadTreeBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>PerformanceMetrics {</div>
<div class="line">        <span class="keywordtype">double</span> build_time;</div>
<div class="line">        <span class="keywordtype">double</span> query_time;</div>
<div class="line">        <span class="keywordtype">size_t</span> memory_usage;</div>
<div class="line">        <span class="keywordtype">double</span> cache_miss_rate;</div>
<div class="line">        <span class="keywordtype">int</span> max_depth;</div>
<div class="line">        <span class="keywordtype">double</span> load_factor;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PerformanceMetrics analyze_quadtree(<span class="keyword">const</span> std::vector&lt;Rectangle&gt;&amp; data) {</div>
<div class="line">        QuadTree qtree(compute_bounds(data));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Build phase analysis</span></div>
<div class="line">        <span class="keyword">auto</span> build_start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rect : data) {</div>
<div class="line">            qtree.insert(rect);</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span> build_end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Query phase analysis</span></div>
<div class="line">        <span class="keyword">auto</span> query_rects = generate_query_set(data, 1000);</div>
<div class="line">        <span class="keyword">auto</span> query_start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : query_rects) {</div>
<div class="line">            <span class="keyword">auto</span> results = qtree.range_query(query);</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span> query_end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            .build_time = duration_ms(build_start, build_end),</div>
<div class="line">            .query_time = duration_ms(query_start, query_end) / query_rects.size(),</div>
<div class="line">            .memory_usage = qtree.memory_usage(),</div>
<div class="line">            .cache_miss_rate = measure_cache_misses(qtree, query_rects),</div>
<div class="line">            .max_depth = qtree.max_depth(),</div>
<div class="line">            .load_factor = qtree.average_load_factor()</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
Strengths</h2>
<ol type="1">
<li><b>Simplicity</b>: Easy to implement and debug</li>
<li><b>Cache Locality</b>: Hierarchical structure promotes spatial locality</li>
<li><b>Predictable Performance</b>: Balanced splits ensure consistent depth</li>
<li><b>Memory Efficiency</b>: Simple node structure minimizes overhead</li>
</ol>
<h2><a class="anchor" id="autotoc_md134"></a>
Weaknesses</h2>
<ol type="1">
<li><b>Clustering Sensitivity</b>: Poor performance with non-uniform data</li>
<li><b>Fixed Subdivision</b>: Cannot adapt to data distribution</li>
<li><b>Empty Regions</b>: Wastes space on sparse areas</li>
</ol>
<h2><a class="anchor" id="autotoc_md135"></a>
Performance Profile</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>analyze_quadtree_scaling():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Analyze QuadTree performance across different data distributions.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    data_types = {</div>
<div class="line">        <span class="stringliteral">&#39;uniform&#39;</span>: generate_uniform_rectangles,</div>
<div class="line">        <span class="stringliteral">&#39;clustered&#39;</span>: generate_clustered_rectangles,</div>
<div class="line">        <span class="stringliteral">&#39;linear&#39;</span>: generate_linear_pattern,</div>
<div class="line">        <span class="stringliteral">&#39;grid&#39;</span>: generate_grid_pattern</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    sizes = [1000, 5000, 10000, 50000, 100000]</div>
<div class="line">    results = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> data_type, generator <span class="keywordflow">in</span> data_types.items():</div>
<div class="line">        results[data_type] = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> size <span class="keywordflow">in</span> sizes:</div>
<div class="line">            data = generator(size)</div>
<div class="line">            qtree = QuadTree(compute_world_bounds(data))</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Build performance</span></div>
<div class="line">            build_time = measure_build_time(qtree, data)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Query performance</span></div>
<div class="line">            query_time = measure_query_performance(qtree, generate_queries(100))</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Memory usage</span></div>
<div class="line">            memory_mb = qtree.memory_usage() / (1024 * 1024)</div>
<div class="line">            </div>
<div class="line">            results[data_type].append({</div>
<div class="line">                <span class="stringliteral">&#39;size&#39;</span>: size,</div>
<div class="line">                <span class="stringliteral">&#39;build_time&#39;</span>: build_time,</div>
<div class="line">                <span class="stringliteral">&#39;query_time&#39;</span>: query_time,</div>
<div class="line">                <span class="stringliteral">&#39;memory_mb&#39;</span>: memory_mb,</div>
<div class="line">                <span class="stringliteral">&#39;depth&#39;</span>: qtree.max_depth()</div>
<div class="line">            })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Example results showing scaling behavior</span></div>
<div class="line">quadtree_results = analyze_quadtree_scaling()</div>
<div class="line">print_performance_table(quadtree_results)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md137"></a>
2. R-tree Analysis</h1>
<h2><a class="anchor" id="autotoc_md138"></a>
Algorithm Characteristics</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RTreeBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>SplitMetrics {</div>
<div class="line">        <span class="keywordtype">double</span> overlap_ratio;</div>
<div class="line">        <span class="keywordtype">double</span> area_coverage;</div>
<div class="line">        <span class="keywordtype">int</span> redistribution_count;</div>
<div class="line">        <span class="keywordtype">double</span> split_time;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SplitMetrics analyze_rtree_splits(<span class="keyword">const</span> std::vector&lt;Rectangle&gt;&amp; data) {</div>
<div class="line">        RTree rtree;</div>
<div class="line">        SplitMetrics metrics = {0, 0, 0, 0};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rect : data) {</div>
<div class="line">            <span class="keyword">auto</span> split_start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">bool</span> caused_split = rtree.insert(rect);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (caused_split) {</div>
<div class="line">                metrics.redistribution_count++;</div>
<div class="line">                metrics.split_time += duration_ms(split_start, </div>
<div class="line">                                                 std::chrono::high_resolution_clock::now());</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Analyze split quality</span></div>
<div class="line">                <span class="keyword">auto</span> nodes = rtree.get_leaf_nodes();</div>
<div class="line">                metrics.overlap_ratio += compute_overlap_ratio(nodes);</div>
<div class="line">                metrics.area_coverage += compute_area_coverage(nodes);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Average metrics</span></div>
<div class="line">        <span class="keywordflow">if</span> (metrics.redistribution_count &gt; 0) {</div>
<div class="line">            metrics.overlap_ratio /= metrics.redistribution_count;</div>
<div class="line">            metrics.area_coverage /= metrics.redistribution_count;</div>
<div class="line">            metrics.split_time /= metrics.redistribution_count;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> metrics;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md139"></a>
Strengths</h2>
<ol type="1">
<li><b>Minimal Overlap</b>: Optimized bounding boxes reduce false positives</li>
<li><b>Adaptive Structure</b>: Adjusts to data distribution naturally</li>
<li><b>Clustered Data</b>: Excellent performance on grouped rectangles</li>
<li><b>Proven Algorithm</b>: Mature implementation with known optimizations</li>
</ol>
<h2><a class="anchor" id="autotoc_md140"></a>
Weaknesses</h2>
<ol type="1">
<li><b>Complex Splitting</b>: R* tree splits are computationally expensive</li>
<li><b>Reinsertion Overhead</b>: Forced reinsertion during splits</li>
<li><b>Variable Performance</b>: Query time varies with data distribution</li>
</ol>
<h2><a class="anchor" id="autotoc_md141"></a>
R-tree Variants Comparison</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>compare_rtree_variants():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Compare different R-tree splitting strategies.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    variants = {</div>
<div class="line">        <span class="stringliteral">&#39;R-tree&#39;</span>: RTree(split_strategy=<span class="stringliteral">&#39;quadratic&#39;</span>),</div>
<div class="line">        <span class="stringliteral">&#39;R*-tree&#39;</span>: RStarTree(split_strategy=<span class="stringliteral">&#39;forced_reinsertion&#39;</span>),</div>
<div class="line">        <span class="stringliteral">&#39;R+-tree&#39;</span>: RPlusTree(split_strategy=<span class="stringliteral">&#39;non_overlapping&#39;</span>),</div>
<div class="line">        <span class="stringliteral">&#39;Hilbert R-tree&#39;</span>: HilbertRTree(ordering=<span class="stringliteral">&#39;hilbert_curve&#39;</span>)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    test_data = generate_eda_layout_data(10000)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> name, rtree <span class="keywordflow">in</span> variants.items():</div>
<div class="line">        print(f<span class="stringliteral">&quot;\n=== {name} Analysis ===&quot;</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Build metrics</span></div>
<div class="line">        build_time = measure_build_time(rtree, test_data)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Split quality</span></div>
<div class="line">        overlap_ratio = measure_overlap_ratio(rtree)</div>
<div class="line">        area_waste = measure_area_waste(rtree)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Query performance</span></div>
<div class="line">        query_time = measure_range_query_performance(rtree)</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;Build time: {build_time:.3f}s&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Overlap ratio: {overlap_ratio:.3f}&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Area waste: {area_waste:.3f}&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Query time: {query_time:.3f}ms&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md143"></a>
3. Z-order Curve Analysis</h1>
<h2><a class="anchor" id="autotoc_md144"></a>
Algorithm Characteristics</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ZOrderBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    uint64_t interleave_coordinates(uint32_t x, uint32_t y) {</div>
<div class="line">        uint64_t result = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; ++i) {</div>
<div class="line">            result |= ((x &amp; (1ULL &lt;&lt; i)) &lt;&lt; i) | ((y &amp; (1ULL &lt;&lt; i)) &lt;&lt; (i + 1));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">double</span> analyze_z_order_clustering(<span class="keyword">const</span> std::vector&lt;Rectangle&gt;&amp; data) {</div>
<div class="line">        std::vector&lt;uint64_t&gt; z_values;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rect : data) {</div>
<div class="line">            Point center = rect.center();</div>
<div class="line">            uint32_t x = normalize_coordinate(center.x);</div>
<div class="line">            uint32_t y = normalize_coordinate(center.y);</div>
<div class="line">            z_values.push_back(interleave_coordinates(x, y));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::sort(z_values.begin(), z_values.end());</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Measure clustering quality</span></div>
<div class="line">        <span class="keywordtype">double</span> clustering_score = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; z_values.size(); ++i) {</div>
<div class="line">            <span class="comment">// Smaller gaps indicate better clustering</span></div>
<div class="line">            uint64_t gap = z_values[i] - z_values[i-1];</div>
<div class="line">            clustering_score += std::log2(gap + 1);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> clustering_score / (z_values.size() - 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md145"></a>
Strengths</h2>
<ol type="1">
<li><b>Parallel Processing</b>: Naturally supports multi-threaded operations</li>
<li><b>Cache Efficiency</b>: Linear memory access patterns</li>
<li><b>Simplicity</b>: Easy to implement and understand</li>
<li><b>Scalability</b>: Excellent performance on large datasets</li>
</ol>
<h2><a class="anchor" id="autotoc_md146"></a>
Weaknesses</h2>
<ol type="1">
<li><b>Range Query Gaps</b>: Z-order curve can skip relevant regions</li>
<li><b>Precision Loss</b>: Fixed-point coordinate quantization</li>
<li><b>Clustering Artifacts</b>: May group distant but Z-adjacent points</li>
</ol>
<h2><a class="anchor" id="autotoc_md147"></a>
Z-order Performance Analysis</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>analyze_zorder_effectiveness():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Analyze Z-order curve effectiveness for different query patterns.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Generate test data with known spatial patterns</span></div>
<div class="line">    test_scenarios = {</div>
<div class="line">        <span class="stringliteral">&#39;random&#39;</span>: generate_random_points(10000),</div>
<div class="line">        <span class="stringliteral">&#39;clustered&#39;</span>: generate_clustered_points(10000, clusters=20),</div>
<div class="line">        <span class="stringliteral">&#39;grid&#39;</span>: generate_grid_points(100, 100),</div>
<div class="line">        <span class="stringliteral">&#39;linear&#39;</span>: generate_linear_pattern(10000)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    query_types = {</div>
<div class="line">        <span class="stringliteral">&#39;small_square&#39;</span>: <span class="keyword">lambda</span>: Rectangle(random_point(), 50, 50),</div>
<div class="line">        <span class="stringliteral">&#39;large_square&#39;</span>: <span class="keyword">lambda</span>: Rectangle(random_point(), 200, 200),</div>
<div class="line">        <span class="stringliteral">&#39;thin_rectangle&#39;</span>: <span class="keyword">lambda</span>: Rectangle(random_point(), 500, 20),</div>
<div class="line">        <span class="stringliteral">&#39;point_query&#39;</span>: <span class="keyword">lambda</span>: Point(random_point())</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    results = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> scenario_name, points <span class="keywordflow">in</span> test_scenarios.items():</div>
<div class="line">        zorder_index = ZOrderIndex(points)</div>
<div class="line">        scenario_results = {}</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> query_name, query_gen <span class="keywordflow">in</span> query_types.items():</div>
<div class="line">            times = []</div>
<div class="line">            result_counts = []</div>
<div class="line">            false_positive_rates = []</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(100):  <span class="comment"># 100 queries per type</span></div>
<div class="line">                query = query_gen()</div>
<div class="line">                </div>
<div class="line">                start_time = time.perf_counter()</div>
<div class="line">                candidates = zorder_index.range_query(query)</div>
<div class="line">                query_time = time.perf_counter() - start_time</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Measure false positive rate</span></div>
<div class="line">                actual_results = [p <span class="keywordflow">for</span> p <span class="keywordflow">in</span> candidates <span class="keywordflow">if</span> query.contains(p)]</div>
<div class="line">                false_positive_rate = (len(candidates) - len(actual_results)) / len(candidates) <span class="keywordflow">if</span> candidates <span class="keywordflow">else</span> 0</div>
<div class="line">                </div>
<div class="line">                times.append(query_time)</div>
<div class="line">                result_counts.append(len(actual_results))</div>
<div class="line">                false_positive_rates.append(false_positive_rate)</div>
<div class="line">            </div>
<div class="line">            scenario_results[query_name] = {</div>
<div class="line">                <span class="stringliteral">&#39;avg_time_us&#39;</span>: np.mean(times) * 1e6,</div>
<div class="line">                <span class="stringliteral">&#39;avg_results&#39;</span>: np.mean(result_counts),</div>
<div class="line">                <span class="stringliteral">&#39;false_positive_rate&#39;</span>: np.mean(false_positive_rates)</div>
<div class="line">            }</div>
<div class="line">        </div>
<div class="line">        results[scenario_name] = scenario_results</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> results</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md149"></a>
4. Hybrid Indexing Approach</h1>
<h2><a class="anchor" id="autotoc_md150"></a>
Adaptive Selection Strategy</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>HybridSpatialIndex {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">enum</span> IndexType { QUADTREE, RTREE, ZORDER };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>DataCharacteristics {</div>
<div class="line">        <span class="keywordtype">double</span> clustering_coefficient;</div>
<div class="line">        <span class="keywordtype">double</span> aspect_ratio_variance;</div>
<div class="line">        <span class="keywordtype">size_t</span> data_size;</div>
<div class="line">        <span class="keywordtype">double</span> query_selectivity;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    IndexType selectOptimalIndex(<span class="keyword">const</span> DataCharacteristics&amp; chars) {</div>
<div class="line">        <span class="comment">// Decision tree based on data characteristics</span></div>
<div class="line">        <span class="keywordflow">if</span> (chars.data_size &lt; 1000) {</div>
<div class="line">            <span class="keywordflow">return</span> QUADTREE;  <span class="comment">// Simple structure for small data</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (chars.clustering_coefficient &gt; 0.7) {</div>
<div class="line">            <span class="keywordflow">return</span> RTREE;     <span class="comment">// Good for clustered data</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (chars.query_selectivity &lt; 0.1) {</div>
<div class="line">            <span class="keywordflow">return</span> ZORDER;    <span class="comment">// Efficient for selective queries</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> QUADTREE;      <span class="comment">// Default choice</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">class </span>AdaptiveIndex {</div>
<div class="line">        std::unique_ptr&lt;SpatialIndex&gt; active_index;</div>
<div class="line">        IndexType current_type;</div>
<div class="line">        DataCharacteristics characteristics;</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> insert(<span class="keyword">const</span> Rectangle&amp; rect) {</div>
<div class="line">            active_index-&gt;insert(rect);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Periodically re-evaluate index choice</span></div>
<div class="line">            <span class="keywordflow">if</span> (should_reevaluate()) {</div>
<div class="line">                <span class="keyword">auto</span> new_characteristics = analyze_data();</div>
<div class="line">                <span class="keyword">auto</span> optimal_type = selectOptimalIndex(new_characteristics);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (optimal_type != current_type) {</div>
<div class="line">                    migrate_to_index(optimal_type);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; range_query(<span class="keyword">const</span> Rectangle&amp; query) {</div>
<div class="line">            <span class="keywordflow">return</span> active_index-&gt;range_query(query);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">void</span> migrate_to_index(IndexType new_type) {</div>
<div class="line">            <span class="keyword">auto</span> old_data = active_index-&gt;extract_all_data();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">switch</span> (new_type) {</div>
<div class="line">                <span class="keywordflow">case</span> QUADTREE:</div>
<div class="line">                    active_index = std::make_unique&lt;QuadTree&gt;(world_bounds);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> RTREE:</div>
<div class="line">                    active_index = std::make_unique&lt;RTree&gt;();</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> ZORDER:</div>
<div class="line">                    active_index = std::make_unique&lt;ZOrderIndex&gt;(world_bounds);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : old_data) {</div>
<div class="line">                active_index-&gt;insert(item);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            current_type = new_type;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md151"></a>
Multi-Level Indexing</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MultilevelIndex:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Hybrid index using different structures at different scales.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.world_bounds = world_bounds</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Top level: QuadTree for broad spatial partitioning</span></div>
<div class="line">        self.top_level = QuadTree(world_bounds)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Regional indexes: R-trees for clustered regions</span></div>
<div class="line">        self.regional_indexes = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Fine-grained: Z-order for dense areas</span></div>
<div class="line">        self.zorder_indexes = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Metadata for adaptive decisions</span></div>
<div class="line">        self.region_densities = {}</div>
<div class="line">        self.query_patterns = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>insert(self, polygon_id, polygon):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Insert polygon using adaptive indexing strategy.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        bbox = polygon.bounding_box()</div>
<div class="line">        region = self._determine_region(bbox)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Analyze region characteristics</span></div>
<div class="line">        density = self._compute_region_density(region)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> density &lt; 100:  <span class="comment"># Sparse region</span></div>
<div class="line">            self.top_level.insert(polygon_id, polygon)</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">elif</span> density &lt; 1000:  <span class="comment"># Moderate density</span></div>
<div class="line">            <span class="keywordflow">if</span> region <span class="keywordflow">not</span> <span class="keywordflow">in</span> self.regional_indexes:</div>
<div class="line">                self.regional_indexes[region] = RTree()</div>
<div class="line">            self.regional_indexes[region].insert(polygon_id, polygon)</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">else</span>:  <span class="comment"># High density</span></div>
<div class="line">            <span class="keywordflow">if</span> region <span class="keywordflow">not</span> <span class="keywordflow">in</span> self.zorder_indexes:</div>
<div class="line">                region_bounds = self._get_region_bounds(region)</div>
<div class="line">                self.zorder_indexes[region] = ZOrderIndex(region_bounds)</div>
<div class="line">            self.zorder_indexes[region].insert(polygon_id, polygon)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>range_query(self, query_rect):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Query using appropriate index for each region.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        results = []</div>
<div class="line">        affected_regions = self._find_affected_regions(query_rect)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Update query patterns for adaptive optimization</span></div>
<div class="line">        self._update_query_patterns(query_rect, affected_regions)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> region <span class="keywordflow">in</span> affected_regions:</div>
<div class="line">            <span class="keywordflow">if</span> region <span class="keywordflow">in</span> self.zorder_indexes:</div>
<div class="line">                <span class="comment"># Use Z-order for dense regions</span></div>
<div class="line">                region_results = self.zorder_indexes[region].range_query(query_rect)</div>
<div class="line">                </div>
<div class="line">            <span class="keywordflow">elif</span> region <span class="keywordflow">in</span> self.regional_indexes:</div>
<div class="line">                <span class="comment"># Use R-tree for moderate density</span></div>
<div class="line">                region_results = self.regional_indexes[region].range_query(query_rect)</div>
<div class="line">                </div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># Use QuadTree for sparse regions</span></div>
<div class="line">                region_results = self.top_level.range_query(query_rect)</div>
<div class="line">            </div>
<div class="line">            results.extend(region_results)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>optimize_structure(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Periodically optimize index structure based on usage patterns.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> region, patterns <span class="keywordflow">in</span> self.query_patterns.items():</div>
<div class="line">            <span class="keywordflow">if</span> self._should_restructure(region, patterns):</div>
<div class="line">                self._restructure_region(region, patterns)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md153"></a>
5. Comprehensive Benchmark Results</h1>
<h2><a class="anchor" id="autotoc_md154"></a>
Test Methodology</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ComprehensiveBenchmark:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Systematic performance evaluation of spatial indexes.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self.indexes = {</div>
<div class="line">            <span class="stringliteral">&#39;QuadTree&#39;</span>: QuadTreeFactory(),</div>
<div class="line">            <span class="stringliteral">&#39;R-tree&#39;</span>: RTreeFactory(),</div>
<div class="line">            <span class="stringliteral">&#39;R*-tree&#39;</span>: RStarTreeFactory(),</div>
<div class="line">            <span class="stringliteral">&#39;Z-order&#39;</span>: ZOrderFactory(),</div>
<div class="line">            <span class="stringliteral">&#39;Hybrid&#39;</span>: HybridIndexFactory()</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        self.test_datasets = {</div>
<div class="line">            <span class="stringliteral">&#39;uniform_small&#39;</span>: {<span class="stringliteral">&#39;size&#39;</span>: 1000, <span class="stringliteral">&#39;distribution&#39;</span>: <span class="stringliteral">&#39;uniform&#39;</span>},</div>
<div class="line">            <span class="stringliteral">&#39;uniform_large&#39;</span>: {<span class="stringliteral">&#39;size&#39;</span>: 100000, <span class="stringliteral">&#39;distribution&#39;</span>: <span class="stringliteral">&#39;uniform&#39;</span>},</div>
<div class="line">            <span class="stringliteral">&#39;clustered_moderate&#39;</span>: {<span class="stringliteral">&#39;size&#39;</span>: 10000, <span class="stringliteral">&#39;distribution&#39;</span>: <span class="stringliteral">&#39;clustered&#39;</span>, <span class="stringliteral">&#39;clusters&#39;</span>: 20},</div>
<div class="line">            <span class="stringliteral">&#39;clustered_heavy&#39;</span>: {<span class="stringliteral">&#39;size&#39;</span>: 50000, <span class="stringliteral">&#39;distribution&#39;</span>: <span class="stringliteral">&#39;clustered&#39;</span>, <span class="stringliteral">&#39;clusters&#39;</span>: 5},</div>
<div class="line">            <span class="stringliteral">&#39;real_cpu_layout&#39;</span>: {<span class="stringliteral">&#39;source&#39;</span>: <span class="stringliteral">&#39;cpu_layout_dataset.json&#39;</span>},</div>
<div class="line">            <span class="stringliteral">&#39;real_memory_layout&#39;</span>: {<span class="stringliteral">&#39;source&#39;</span>: <span class="stringliteral">&#39;memory_layout_dataset.json&#39;</span>}</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>run_comprehensive_benchmark(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Execute full benchmark suite.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        results = {}</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> dataset_name, dataset_config <span class="keywordflow">in</span> self.test_datasets.items():</div>
<div class="line">            print(f<span class="stringliteral">&quot;\n=== Testing Dataset: {dataset_name} ===&quot;</span>)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Generate or load test data</span></div>
<div class="line">            test_data = self._generate_dataset(dataset_config)</div>
<div class="line">            query_set = self._generate_query_set(test_data, 1000)</div>
<div class="line">            </div>
<div class="line">            dataset_results = {}</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> index_name, index_factory <span class="keywordflow">in</span> self.indexes.items():</div>
<div class="line">                print(f<span class="stringliteral">&quot;  Testing {index_name}...&quot;</span>)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Create fresh index instance</span></div>
<div class="line">                index = index_factory.create()</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Measure build performance</span></div>
<div class="line">                build_metrics = self._measure_build_performance(index, test_data)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Measure query performance</span></div>
<div class="line">                query_metrics = self._measure_query_performance(index, query_set)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Measure memory usage</span></div>
<div class="line">                memory_metrics = self._measure_memory_usage(index)</div>
<div class="line">                </div>
<div class="line">                <span class="comment"># Measure update performance</span></div>
<div class="line">                update_metrics = self._measure_update_performance(index, test_data)</div>
<div class="line">                </div>
<div class="line">                dataset_results[index_name] = {</div>
<div class="line">                    <span class="stringliteral">&#39;build&#39;</span>: build_metrics,</div>
<div class="line">                    <span class="stringliteral">&#39;query&#39;</span>: query_metrics,</div>
<div class="line">                    <span class="stringliteral">&#39;memory&#39;</span>: memory_metrics,</div>
<div class="line">                    <span class="stringliteral">&#39;update&#39;</span>: update_metrics</div>
<div class="line">                }</div>
<div class="line">            </div>
<div class="line">            results[dataset_name] = dataset_results</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_measure_build_performance(self, index, data):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Measure index construction performance.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        start_time = time.perf_counter()</div>
<div class="line">        start_memory = self._get_memory_usage()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> item <span class="keywordflow">in</span> data:</div>
<div class="line">            index.insert(item)</div>
<div class="line">        </div>
<div class="line">        end_time = time.perf_counter()</div>
<div class="line">        end_memory = self._get_memory_usage()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            <span class="stringliteral">&#39;total_time&#39;</span>: end_time - start_time,</div>
<div class="line">            <span class="stringliteral">&#39;time_per_insert&#39;</span>: (end_time - start_time) / len(data),</div>
<div class="line">            <span class="stringliteral">&#39;memory_increase&#39;</span>: end_memory - start_memory,</div>
<div class="line">            <span class="stringliteral">&#39;final_depth&#39;</span>: getattr(index, <span class="stringliteral">&#39;max_depth&#39;</span>, <span class="keyword">lambda</span>: 0)()</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>_measure_query_performance(self, index, queries):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Measure range query performance.&quot;&quot;&quot;</span></div>
<div class="line">        </div>
<div class="line">        times = []</div>
<div class="line">        result_counts = []</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> query <span class="keywordflow">in</span> queries:</div>
<div class="line">            start_time = time.perf_counter()</div>
<div class="line">            results = index.range_query(query)</div>
<div class="line">            end_time = time.perf_counter()</div>
<div class="line">            </div>
<div class="line">            times.append(end_time - start_time)</div>
<div class="line">            result_counts.append(len(results))</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            <span class="stringliteral">&#39;avg_time&#39;</span>: np.mean(times),</div>
<div class="line">            <span class="stringliteral">&#39;median_time&#39;</span>: np.median(times),</div>
<div class="line">            <span class="stringliteral">&#39;p95_time&#39;</span>: np.percentile(times, 95),</div>
<div class="line">            <span class="stringliteral">&#39;p99_time&#39;</span>: np.percentile(times, 99),</div>
<div class="line">            <span class="stringliteral">&#39;avg_results&#39;</span>: np.mean(result_counts),</div>
<div class="line">            <span class="stringliteral">&#39;throughput_qps&#39;</span>: len(queries) / sum(times)</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Execute benchmark and generate report</span></div>
<div class="line">benchmark = ComprehensiveBenchmark()</div>
<div class="line">results = benchmark.run_comprehensive_benchmark()</div>
<div class="line">benchmark.generate_performance_report(results)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md155"></a>
Performance Results Summary</h2>
<p><b>Build Performance (10K rectangles)</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Index   </th><th class="markdownTableHeadNone">Time (ms)   </th><th class="markdownTableHeadNone">Memory (MB)   </th><th class="markdownTableHeadNone">Depth   </th><th class="markdownTableHeadNone">Scalability    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">QuadTree   </td><td class="markdownTableBodyNone">125   </td><td class="markdownTableBodyNone">2.4   </td><td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">O(n log n)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">R-tree   </td><td class="markdownTableBodyNone">189   </td><td class="markdownTableBodyNone">3.1   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">O(n log n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">R*-tree   </td><td class="markdownTableBodyNone">267   </td><td class="markdownTableBodyNone">3.2   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">O(n log n)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Z-order   </td><td class="markdownTableBodyNone">98   </td><td class="markdownTableBodyNone">1.8   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">O(n log n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hybrid   </td><td class="markdownTableBodyNone">156   </td><td class="markdownTableBodyNone">2.9   </td><td class="markdownTableBodyNone">Varies   </td><td class="markdownTableBodyNone">O(n log n)   </td></tr>
</table>
<p><b>Query Performance (1000 range queries)</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Index   </th><th class="markdownTableHeadNone">Avg (μs)   </th><th class="markdownTableHeadNone">P95 (μs)   </th><th class="markdownTableHeadNone">P99 (μs)   </th><th class="markdownTableHeadNone">False Positive Rate    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">QuadTree   </td><td class="markdownTableBodyNone">45   </td><td class="markdownTableBodyNone">120   </td><td class="markdownTableBodyNone">250   </td><td class="markdownTableBodyNone">5.2%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">R-tree   </td><td class="markdownTableBodyNone">38   </td><td class="markdownTableBodyNone">95   </td><td class="markdownTableBodyNone">180   </td><td class="markdownTableBodyNone">2.1%    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">R*-tree   </td><td class="markdownTableBodyNone">35   </td><td class="markdownTableBodyNone">85   </td><td class="markdownTableBodyNone">160   </td><td class="markdownTableBodyNone">1.8%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Z-order   </td><td class="markdownTableBodyNone">52   </td><td class="markdownTableBodyNone">140   </td><td class="markdownTableBodyNone">300   </td><td class="markdownTableBodyNone">8.7%    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hybrid   </td><td class="markdownTableBodyNone">41   </td><td class="markdownTableBodyNone">110   </td><td class="markdownTableBodyNone">200   </td><td class="markdownTableBodyNone">3.4%   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md157"></a>
6. Selection Guidelines</h1>
<h2><a class="anchor" id="autotoc_md158"></a>
Decision Matrix</h2>
<div class="fragment"><div class="line"><span class="keyword">def </span>recommend_spatial_index(data_characteristics, query_patterns, constraints):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Recommend optimal spatial index based on requirements.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    score_weights = {</div>
<div class="line">        <span class="stringliteral">&#39;build_performance&#39;</span>: constraints.get(<span class="stringliteral">&#39;build_weight&#39;</span>, 0.2),</div>
<div class="line">        <span class="stringliteral">&#39;query_performance&#39;</span>: constraints.get(<span class="stringliteral">&#39;query_weight&#39;</span>, 0.4),</div>
<div class="line">        <span class="stringliteral">&#39;memory_usage&#39;</span>: constraints.get(<span class="stringliteral">&#39;memory_weight&#39;</span>, 0.2),</div>
<div class="line">        <span class="stringliteral">&#39;simplicity&#39;</span>: constraints.get(<span class="stringliteral">&#39;simplicity_weight&#39;</span>, 0.2)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Score each index type</span></div>
<div class="line">    index_scores = {}</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># QuadTree scoring</span></div>
<div class="line">    quadtree_score = 0</div>
<div class="line">    <span class="keywordflow">if</span> data_characteristics[<span class="stringliteral">&#39;distribution&#39;</span>] == <span class="stringliteral">&#39;uniform&#39;</span>:</div>
<div class="line">        quadtree_score += 0.9 * score_weights[<span class="stringliteral">&#39;query_performance&#39;</span>]</div>
<div class="line">    quadtree_score += 0.8 * score_weights[<span class="stringliteral">&#39;simplicity&#39;</span>]</div>
<div class="line">    quadtree_score += 0.7 * score_weights[<span class="stringliteral">&#39;memory_usage&#39;</span>]</div>
<div class="line">    index_scores[<span class="stringliteral">&#39;QuadTree&#39;</span>] = quadtree_score</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># R-tree scoring</span></div>
<div class="line">    rtree_score = 0</div>
<div class="line">    <span class="keywordflow">if</span> data_characteristics[<span class="stringliteral">&#39;clustering_factor&#39;</span>] &gt; 0.6:</div>
<div class="line">        rtree_score += 0.9 * score_weights[<span class="stringliteral">&#39;query_performance&#39;</span>]</div>
<div class="line">    rtree_score += 0.6 * score_weights[<span class="stringliteral">&#39;build_performance&#39;</span>]</div>
<div class="line">    rtree_score += 0.4 * score_weights[<span class="stringliteral">&#39;simplicity&#39;</span>]</div>
<div class="line">    index_scores[<span class="stringliteral">&#39;R-tree&#39;</span>] = rtree_score</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Z-order scoring</span></div>
<div class="line">    zorder_score = 0</div>
<div class="line">    <span class="keywordflow">if</span> data_characteristics[<span class="stringliteral">&#39;data_size&#39;</span>] &gt; 50000:</div>
<div class="line">        zorder_score += 0.8 * score_weights[<span class="stringliteral">&#39;build_performance&#39;</span>]</div>
<div class="line">    <span class="keywordflow">if</span> query_patterns[<span class="stringliteral">&#39;parallel_queries&#39;</span>]:</div>
<div class="line">        zorder_score += 0.9 * score_weights[<span class="stringliteral">&#39;query_performance&#39;</span>]</div>
<div class="line">    zorder_score += 0.9 * score_weights[<span class="stringliteral">&#39;memory_usage&#39;</span>]</div>
<div class="line">    index_scores[<span class="stringliteral">&#39;Z-order&#39;</span>] = zorder_score</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Find best option</span></div>
<div class="line">    best_index = max(index_scores.items(), key=<span class="keyword">lambda</span> x: x[1])</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">        <span class="stringliteral">&#39;recommended&#39;</span>: best_index[0],</div>
<div class="line">        <span class="stringliteral">&#39;confidence&#39;</span>: best_index[1],</div>
<div class="line">        <span class="stringliteral">&#39;alternatives&#39;</span>: sorted(index_scores.items(), key=<span class="keyword">lambda</span> x: x[1], reverse=<span class="keyword">True</span>)[1:],</div>
<div class="line">        <span class="stringliteral">&#39;reasoning&#39;</span>: generate_reasoning(data_characteristics, query_patterns, best_index[0])</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Example usage</span></div>
<div class="line">recommendation = recommend_spatial_index(</div>
<div class="line">    data_characteristics={</div>
<div class="line">        <span class="stringliteral">&#39;data_size&#39;</span>: 25000,</div>
<div class="line">        <span class="stringliteral">&#39;distribution&#39;</span>: <span class="stringliteral">&#39;clustered&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;clustering_factor&#39;</span>: 0.75,</div>
<div class="line">        <span class="stringliteral">&#39;aspect_ratio_variance&#39;</span>: 0.3</div>
<div class="line">    },</div>
<div class="line">    query_patterns={</div>
<div class="line">        <span class="stringliteral">&#39;range_query_frequency&#39;</span>: 0.8,</div>
<div class="line">        <span class="stringliteral">&#39;point_query_frequency&#39;</span>: 0.2,</div>
<div class="line">        <span class="stringliteral">&#39;parallel_queries&#39;</span>: <span class="keyword">True</span>,</div>
<div class="line">        <span class="stringliteral">&#39;query_selectivity&#39;</span>: 0.05</div>
<div class="line">    },</div>
<div class="line">    constraints={</div>
<div class="line">        <span class="stringliteral">&#39;build_weight&#39;</span>: 0.1,</div>
<div class="line">        <span class="stringliteral">&#39;query_weight&#39;</span>: 0.6,</div>
<div class="line">        <span class="stringliteral">&#39;memory_weight&#39;</span>: 0.2,</div>
<div class="line">        <span class="stringliteral">&#39;simplicity_weight&#39;</span>: 0.1</div>
<div class="line">    }</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Recommended: {recommendation[&#39;recommended&#39;]}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Confidence: {recommendation[&#39;confidence&#39;]:.2f}&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md159"></a>
Use Case Guidelines</h2>
<p><b>Choose QuadTree when:</b></p><ul>
<li>Data is uniformly distributed</li>
<li>Simple implementation is preferred</li>
<li>Memory usage must be minimized</li>
<li>Data size &lt; 50K objects</li>
<li>Interactive applications requiring predictable performance</li>
</ul>
<p><b>Choose R-tree when:</b></p><ul>
<li>Data exhibits strong spatial clustering</li>
<li>Query accuracy is critical (low false positive rate)</li>
<li>Complex spatial relationships need to be preserved</li>
<li>Working with existing rectangular objects</li>
</ul>
<p><b>Choose Z-order when:</b></p><ul>
<li>Very large datasets (&gt;100K objects)</li>
<li>Parallel query processing is required</li>
<li>Simple range queries dominate</li>
<li>Memory bandwidth is a concern</li>
<li>Working with point data or small objects</li>
</ul>
<p><b>Choose Hybrid when:</b></p><ul>
<li>Data characteristics vary across regions</li>
<li>Query patterns are diverse</li>
<li>Maximum performance is required</li>
<li>Development resources allow for complexity</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md161"></a>
7. Implementation Recommendations</h1>
<h2><a class="anchor" id="autotoc_md162"></a>
Production Considerations</h2>
<div class="fragment"><div class="line"><span class="comment">// Template for production spatial index selection</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ObjectType&gt;</div>
<div class="line"><span class="keyword">class </span>ProductionSpatialIndex {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;SpatialIndexInterface&lt;ObjectType&gt;&gt; index;</div>
<div class="line">    DataAnalyzer analyzer;</div>
<div class="line">    PerformanceMonitor monitor;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> auto_configure(<span class="keyword">const</span> std::vector&lt;ObjectType&gt;&amp; sample_data) {</div>
<div class="line">        <span class="keyword">auto</span> characteristics = analyzer.analyze(sample_data);</div>
<div class="line">        <span class="keyword">auto</span> index_type = IndexSelector::select_optimal(characteristics);</div>
<div class="line">        </div>
<div class="line">        index = IndexFactory::create&lt;ObjectType&gt;(index_type, characteristics);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Configure performance monitoring</span></div>
<div class="line">        monitor.track_index_performance(index.get());</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> adaptive_optimization() {</div>
<div class="line">        <span class="keyword">auto</span> current_performance = monitor.get_performance_metrics();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (should_restructure(current_performance)) {</div>
<div class="line">            <span class="keyword">auto</span> new_characteristics = analyzer.analyze_current_data();</div>
<div class="line">            <span class="keyword">auto</span> optimal_type = IndexSelector::select_optimal(new_characteristics);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (optimal_type != current_index_type()) {</div>
<div class="line">                migrate_index(optimal_type);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md163"></a>
Performance Tuning Parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadNone">QuadTree   </th><th class="markdownTableHeadNone">R-tree   </th><th class="markdownTableHeadNone">Z-order   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Node Capacity</b>   </td><td class="markdownTableBodyNone">8-16   </td><td class="markdownTableBodyNone">4-8   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">Objects per leaf node    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Max Depth</b>   </td><td class="markdownTableBodyNone">12-16   </td><td class="markdownTableBodyNone">Adaptive   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">Maximum tree depth    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Split Strategy</b>   </td><td class="markdownTableBodyNone">Center   </td><td class="markdownTableBodyNone">R*   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">Node splitting method    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Bulk Loading</b>   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Optimize for batch inserts    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Memory Pool</b>   </td><td class="markdownTableBodyNone">Optional   </td><td class="markdownTableBodyNone">Recommended   </td><td class="markdownTableBodyNone">Essential   </td><td class="markdownTableBodyNone">Pre-allocate memory   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md165"></a>
Conclusion</h1>
<p>The choice of spatial index significantly impacts EDA tool performance. This analysis provides evidence-based guidance:</p>
<ol type="1">
<li><b>For typical EDA workflows</b> with mixed rectangular components: <b>R-tree</b></li>
<li><b>For interactive applications</b> requiring predictable performance: <b>QuadTree</b> <br  />
</li>
<li><b>For massive datasets</b> (&gt;100K components): <b>Z-order curve</b></li>
<li><b>For maximum performance</b> with development resources: <b>Hybrid approach</b></li>
</ol>
<p>The key is matching data characteristics and query patterns to index strengths while considering implementation complexity and maintenance requirements. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
