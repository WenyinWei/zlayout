<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: 尖角检测算法</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2zh_2algorithms_2sharp__angle__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">尖角检测算法</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md249"></a> <em>设计规则检查(DRC)的核心算法</em></p>
<h1><a class="anchor" id="autotoc_md250"></a>
概述</h1>
<p>尖角检测是电子设计自动化中的基础几何分析算法。它用于识别多边形中内角小于指定阈值的顶点，这对于制造可行性和设计规则检查至关重要。</p>
<h1><a class="anchor" id="autotoc_md251"></a>
目录</h1>
<ol type="1">
<li>问题定义</li>
<li>算法原理</li>
<li>实现方法</li>
<li>复杂度分析</li>
<li>交互式教程</li>
<li>性能基准测试</li>
<li>空间索引优化</li>
<li>实际应用</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md253"></a>
问题定义</h1>
<h2><a class="anchor" id="autotoc_md254"></a>
什么是尖角？</h2>
<p>在EDA布局中，尖角会带来制造挑战：</p>
<ul>
<li>**蚀刻问题**：尖角可能导致过度蚀刻或蚀刻不足</li>
<li>**应力集中**：尖角会产生机械应力集中点</li>
<li>**工艺变化**：制造公差对尖角特征影响更严重</li>
</ul>
<h2><a class="anchor" id="autotoc_md255"></a>
数学定义</h2>
<p>对于位置为<code>P</code>的多边形顶点，相邻顶点为<code>P_prev</code>和<code>P_next</code>：</p>
<div class="fragment"><div class="line">内角 θ = arccos((v1 · v2) / (|v1| × |v2|))</div>
<div class="line"> </div>
<div class="line">其中：</div>
<div class="line">v1 = P_prev - P</div>
<div class="line">v2 = P_next - P</div>
</div><!-- fragment --><p>当 θ &lt; 阈值（通常为30°到60°）时，角度被认为是"尖角"。</p>
<hr  />
<h1><a class="anchor" id="autotoc_md257"></a>
算法原理</h1>
<h2><a class="anchor" id="autotoc_md258"></a>
核心算法步骤</h2>
<ol type="1">
<li><b>遍历顶点</b> - 遍历多边形的所有顶点</li>
<li><b>计算向量</b> - 从当前顶点到相邻顶点的向量</li>
<li><b>计算点积</b> - 计算向量点积和模长</li>
<li><b>计算角度</b> - 使用反余弦函数计算角度</li>
<li><b>比较阈值</b> - 与阈值比较并收集违规顶点</li>
</ol>
<h2><a class="anchor" id="autotoc_md259"></a>
边缘情况处理</h2>
<ul>
<li><b>共线顶点</b> (角度 = 180°)</li>
<li><b>自相交多边形</b></li>
<li><b>退化三角形</b> (面积 ≈ 0)</li>
<li><b>数值精度</b> 问题</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md261"></a>
实现方法</h1>
<h2><a class="anchor" id="autotoc_md262"></a>
方法1：基础向量数学</h2>
<div class="fragment"><div class="line"><span class="comment">// C++ 实现</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">double</span> x, y;</div>
<div class="line">    Point(<span class="keywordtype">double</span> x = 0, <span class="keywordtype">double</span> y = 0) : x(x), y(y) {}</div>
<div class="line">    Point operator-(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> Point(x - other.x, y - other.y);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharpAngleDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;int&gt; detectSharpAngles(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, </div>
<div class="line">        <span class="keywordtype">double</span> threshold_degrees = 30.0</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;int&gt; sharp_vertices;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> threshold_rad = threshold_degrees * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 180.0;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            <span class="comment">// 获取三个连续顶点</span></div>
<div class="line">            <span class="keyword">const</span> Point&amp; prev = vertices[(i - 1 + n) % n];</div>
<div class="line">            <span class="keyword">const</span> Point&amp; curr = vertices[i];</div>
<div class="line">            <span class="keyword">const</span> Point&amp; next = vertices[(i + 1) % n];</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 计算从当前顶点出发的向量</span></div>
<div class="line">            Point v1 = prev - curr;</div>
<div class="line">            Point v2 = next - curr;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 计算向量模长</span></div>
<div class="line">            <span class="keywordtype">double</span> mag1 = sqrt(v1.x * v1.x + v1.y * v1.y);</div>
<div class="line">            <span class="keywordtype">double</span> mag2 = sqrt(v2.x * v2.x + v2.y * v2.y);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 避免除零</span></div>
<div class="line">            <span class="keywordflow">if</span> (mag1 &lt; 1e-10 || mag2 &lt; 1e-10) <span class="keywordflow">continue</span>;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 计算点积和角度</span></div>
<div class="line">            <span class="keywordtype">double</span> dot_product = v1.x * v2.x + v1.y * v2.y;</div>
<div class="line">            <span class="keywordtype">double</span> cos_angle = dot_product / (mag1 * mag2);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 限制acos的有效范围</span></div>
<div class="line">            cos_angle = std::max(-1.0, std::min(1.0, cos_angle));</div>
<div class="line">            <span class="keywordtype">double</span> angle = acos(cos_angle);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 检查是否为尖角</span></div>
<div class="line">            <span class="keywordflow">if</span> (angle &lt; threshold_rad) {</div>
<div class="line">                sharp_vertices.push_back(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="apolygon_8cpp_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdef"><b>Definition</b> <a href="polygon_8cpp_source.html#l00015">polygon.cpp:15</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md263"></a>
方法2：叉积方法（更稳健）</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RobustSharpAngleDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;int&gt; detectSharpAngles(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, </div>
<div class="line">        <span class="keywordtype">double</span> threshold_degrees = 30.0</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;int&gt; sharp_vertices;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            <span class="keywordtype">double</span> angle = calculateInteriorAngle(vertices, i);</div>
<div class="line">            <span class="keywordflow">if</span> (angle &lt; threshold_degrees &amp;&amp; angle &gt; 0) {</div>
<div class="line">                sharp_vertices.push_back(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> calculateInteriorAngle(<span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, <span class="keywordtype">int</span> index) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        <span class="keyword">const</span> Point&amp; prev = vertices[(index - 1 + n) % n];</div>
<div class="line">        <span class="keyword">const</span> Point&amp; curr = vertices[index];</div>
<div class="line">        <span class="keyword">const</span> Point&amp; next = vertices[(index + 1) % n];</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 使用atan2提高数值稳定性</span></div>
<div class="line">        <span class="keywordtype">double</span> angle1 = atan2(prev.y - curr.y, prev.x - curr.x);</div>
<div class="line">        <span class="keywordtype">double</span> angle2 = atan2(next.y - curr.y, next.x - curr.x);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> angle_diff = angle2 - angle1;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 标准化到[0, 2π]</span></div>
<div class="line">        <span class="keywordflow">while</span> (angle_diff &lt; 0) angle_diff += 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        <span class="keywordflow">while</span> (angle_diff &gt; 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>) angle_diff -= 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 转换为角度并处理凸/凹多边形</span></div>
<div class="line">        <span class="keywordtype">double</span> interior_angle = angle_diff * 180.0 / <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        <span class="keywordflow">if</span> (interior_angle &gt; 180.0) {</div>
<div class="line">            interior_angle = 360.0 - interior_angle;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> interior_angle;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md264"></a>
Python 实现</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> math</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Tuple</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharpAngleDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;用于EDA布局的高性能尖角检测器&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>detect_sharp_angles(vertices: List[Tuple[float, float]], </div>
<div class="line">                          threshold_degrees: float = 30.0) -&gt; List[int]:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        检测角度小于阈值的尖角顶点</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        参数:</span></div>
<div class="line"><span class="stringliteral">            vertices: (x, y) 坐标元组列表</span></div>
<div class="line"><span class="stringliteral">            threshold_degrees: 角度阈值（度数）</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        返回:</span></div>
<div class="line"><span class="stringliteral">            包含尖角的顶点索引列表</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        sharp_vertices = []</div>
<div class="line">        n = len(vertices)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> n &lt; 3:</div>
<div class="line">            <span class="keywordflow">return</span> sharp_vertices</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line">            <span class="comment"># 获取三个连续顶点</span></div>
<div class="line">            prev_vertex = vertices[(i - 1) % n]</div>
<div class="line">            curr_vertex = vertices[i]</div>
<div class="line">            next_vertex = vertices[(i + 1) % n]</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 计算内角</span></div>
<div class="line">            angle = SharpAngleDetector._calculate_interior_angle(</div>
<div class="line">                prev_vertex, curr_vertex, next_vertex</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> 0 &lt; angle &lt; threshold_degrees:</div>
<div class="line">                sharp_vertices.append(i)</div>
<div class="line">                </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>_calculate_interior_angle(prev_pt: Tuple[float, float], </div>
<div class="line">                                curr_pt: Tuple[float, float], </div>
<div class="line">                                next_pt: Tuple[float, float]) -&gt; float:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;使用atan2计算当前顶点的内角&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 从当前点到相邻点的向量</span></div>
<div class="line">        v1 = (prev_pt[0] - curr_pt[0], prev_pt[1] - curr_pt[1])</div>
<div class="line">        v2 = (next_pt[0] - curr_pt[0], next_pt[1] - curr_pt[1])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 使用atan2计算角度以提高数值稳定性</span></div>
<div class="line">        angle1 = math.atan2(v1[1], v1[0])</div>
<div class="line">        angle2 = math.atan2(v2[1], v2[0])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 计算内角</span></div>
<div class="line">        angle_diff = angle2 - angle1</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 标准化到[0, 2π]</span></div>
<div class="line">        <span class="keywordflow">while</span> angle_diff &lt; 0:</div>
<div class="line">            angle_diff += 2 * math.pi</div>
<div class="line">        <span class="keywordflow">while</span> angle_diff &gt; 2 * math.pi:</div>
<div class="line">            angle_diff -= 2 * math.pi</div>
<div class="line">            </div>
<div class="line">        <span class="comment"># 转换为度数</span></div>
<div class="line">        interior_angle = math.degrees(angle_diff)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 处理凸多边形（内角 &lt; 180°）</span></div>
<div class="line">        <span class="keywordflow">if</span> interior_angle &gt; 180:</div>
<div class="line">            interior_angle = 360 - interior_angle</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">return</span> interior_angle</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md266"></a>
复杂度分析</h1>
<h2><a class="anchor" id="autotoc_md267"></a>
时间复杂度</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">实现方式   </th><th class="markdownTableHeadNone">最好情况   </th><th class="markdownTableHeadNone">平均情况   </th><th class="markdownTableHeadNone">最坏情况   </th><th class="markdownTableHeadNone">空间复杂度    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">基础算法   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">空间索引   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">批处理   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(k)   </td></tr>
</table>
<p>其中：</p><ul>
<li><code>n</code> = 多边形顶点数</li>
<li><code>k</code> = 多边形数量</li>
</ul>
<h2><a class="anchor" id="autotoc_md268"></a>
详细分析</h2>
<p><b>单多边形分析：</b> </p><div class="fragment"><div class="line">对每个顶点（n次迭代）：</div>
<div class="line">  - 向量计算：O(1)</div>
<div class="line">  - 点积计算：O(1)  </div>
<div class="line">  - 模长计算：O(1)</div>
<div class="line">  - 角度计算：O(1)</div>
<div class="line">  </div>
<div class="line">总计：每个多边形 O(n)</div>
</div><!-- fragment --><p><b>多多边形分析：</b> </p><div class="fragment"><div class="line">对于k个平均有n个顶点的多边形：</div>
<div class="line">  - 朴素方法：O(k × n)</div>
<div class="line">  - 空间索引：O(k × n) [相同复杂度，但常数更小]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md269"></a>
内存复杂度</h2>
<ul>
<li>**输入**：O(n) 用于顶点存储</li>
<li>**输出**：O(s) 其中 s ≤ n 是尖角数量</li>
<li>**工作内存**：O(1) 用于计算</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md271"></a>
交互式教程</h1>
<h2><a class="anchor" id="autotoc_md272"></a>
教程1：基础尖角检测</h2>
<div class="fragment"><div class="line"><span class="comment"># 从一个简单例子开始</span></div>
<div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 创建一个已知包含尖角的多边形</span></div>
<div class="line">vertices = [</div>
<div class="line">    (0.0, 0.0),    <span class="comment"># 普通顶点</span></div>
<div class="line">    (10.0, 0.0),   <span class="comment"># 普通顶点  </span></div>
<div class="line">    (5.0, 1.0),    <span class="comment"># 尖角！（非常锐的三角形）</span></div>
<div class="line">    (2.0, 8.0),    <span class="comment"># 普通顶点</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">polygon = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>(vertices)</div>
<div class="line">detector = zlayout.SharpAngleDetector()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 使用45°阈值检测尖角</span></div>
<div class="line">sharp_indices = detector.detect_sharp_angles(polygon.vertices, threshold_degrees=45.0)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;尖角顶点: {sharp_indices}&quot;</span>)</div>
<div class="line"><span class="comment"># 预期输出: [2] (锐角三角形顶点)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 计算实际角度进行验证</span></div>
<div class="line"><span class="keywordflow">for</span> i, vertex <span class="keywordflow">in</span> enumerate(polygon.vertices):</div>
<div class="line">    angle = detector.calculate_vertex_angle(polygon.vertices, i)</div>
<div class="line">    marker = <span class="stringliteral">&quot; &lt;- 尖角!&quot;</span> <span class="keywordflow">if</span> i <span class="keywordflow">in</span> sharp_indices <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;顶点 {i}: {angle:.1f}°{marker}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_polygon_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_polygon.html">zlayout::geometry::Polygon</a></div><div class="ttdoc">Polygon class supporting both convex and concave polygons.</div><div class="ttdef"><b>Definition</b> <a href="polygon_8hpp_source.html#l00025">polygon.hpp:25</a></div></div>
</div><!-- fragment --><p><b>预期输出：</b> </p><div class="fragment"><div class="line">尖角顶点: [2]</div>
<div class="line">顶点 0: 168.7°</div>
<div class="line">顶点 1: 163.1° </div>
<div class="line">顶点 2: 11.3° &lt;- 尖角!</div>
<div class="line">顶点 3: 116.9°</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md273"></a>
教程2：制造工艺验证</h2>
<div class="fragment"><div class="line"><span class="comment"># 模拟不同制造工艺</span></div>
<div class="line">process_rules = {</div>
<div class="line">    <span class="stringliteral">&quot;28nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 45.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;28nm工艺节点&quot;</span>},</div>
<div class="line">    <span class="stringliteral">&quot;14nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 30.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;14nm工艺节点&quot;</span>},  </div>
<div class="line">    <span class="stringliteral">&quot;7nm&quot;</span>:  {<span class="stringliteral">&quot;min_angle&quot;</span>: 20.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;7nm工艺节点&quot;</span>},</div>
<div class="line">    <span class="stringliteral">&quot;3nm&quot;</span>:  {<span class="stringliteral">&quot;min_angle&quot;</span>: 15.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;3nm工艺节点&quot;</span>},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 来自真实CPU布局的测试多边形（简化）</span></div>
<div class="line">cpu_components = [</div>
<div class="line">    <span class="comment"># ALU组件轮廓</span></div>
<div class="line">    [(0, 0), (100, 0), (100, 80), (95, 85), (0, 80)],</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 可能有尖角的缓存线</span></div>
<div class="line">    [(150, 10), (250, 10), (250, 70), (240, 75), (140, 70), (140, 15)],</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 有紧约束的关键时序路径</span></div>
<div class="line">    [(300, 20), (320, 22), (302, 45), (285, 40)]  <span class="comment"># 非常尖的角</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> process_name, rules <span class="keywordflow">in</span> process_rules.items():</div>
<div class="line">    print(f<span class="stringliteral">&quot;\n=== {rules[&#39;description&#39;]} ===&quot;</span>)</div>
<div class="line">    total_violations = 0</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> i, component_vertices <span class="keywordflow">in</span> enumerate(cpu_components):</div>
<div class="line">        polygon = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>(component_vertices)</div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            polygon.vertices, </div>
<div class="line">            threshold_degrees=rules[<span class="stringliteral">&#39;min_angle&#39;</span>]</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        violations = len(sharp_angles)</div>
<div class="line">        total_violations += violations</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;组件 {i+1}: {violations} 个违规&quot;</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 显示违反规则的具体角度</span></div>
<div class="line">        <span class="keywordflow">for</span> vertex_idx <span class="keywordflow">in</span> sharp_angles:</div>
<div class="line">            angle = detector.calculate_vertex_angle(polygon.vertices, vertex_idx)</div>
<div class="line">            print(f<span class="stringliteral">&quot;  顶点 {vertex_idx}: {angle:.1f}° &lt; {rules[&#39;min_angle&#39;]}°&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    status = <span class="stringliteral">&quot;通过&quot;</span> <span class="keywordflow">if</span> total_violations == 0 <span class="keywordflow">else</span> f<span class="stringliteral">&quot;失败 ({total_violations} 个违规)&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;工艺验证: {status}&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md274"></a>
教程3：性能优化</h2>
<div class="fragment"><div class="line"><span class="comment"># 基准测试不同检测算法</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> random</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_test_polygon(num_vertices, sharp_angle_ratio=0.1):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;生成具有可控尖角的多边形用于测试&quot;&quot;&quot;</span></div>
<div class="line">    vertices = []</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 在粗糙圆形上生成点</span></div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(num_vertices):</div>
<div class="line">        angle = 2 * math.pi * i / num_vertices</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 添加一些随机性</span></div>
<div class="line">        radius = 50 + random.uniform(-10, 10)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 偶尔创建尖角</span></div>
<div class="line">        <span class="keywordflow">if</span> random.random() &lt; sharp_angle_ratio:</div>
<div class="line">            radius *= 0.3  <span class="comment"># 向内拉顶点以创建尖角</span></div>
<div class="line">            </div>
<div class="line">        x = radius * math.cos(angle)</div>
<div class="line">        y = radius * math.sin(angle)</div>
<div class="line">        vertices.append((x, y))</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> vertices</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 性能比较</span></div>
<div class="line">test_sizes = [100, 1000, 10000, 100000]</div>
<div class="line">algorithms = {</div>
<div class="line">    <span class="stringliteral">&quot;基础向量&quot;</span>: detector.detect_sharp_angles_basic,</div>
<div class="line">    <span class="stringliteral">&quot;稳健atan2&quot;</span>: detector.detect_sharp_angles_robust,</div>
<div class="line">    <span class="stringliteral">&quot;NumPy向量化&quot;</span>: detector.detect_sharp_angles_numpy</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;性能比较（尖角检测）&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;-&quot;</span> * 60)</div>
<div class="line">print(f<span class="stringliteral">&quot;{&#39;顶点数&#39;:&lt;10} {&#39;算法&#39;:&lt;15} {&#39;时间(ms)&#39;:&lt;12} {&#39;检测到&#39;:&lt;8}&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;-&quot;</span> * 60)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> size <span class="keywordflow">in</span> test_sizes:</div>
<div class="line">    test_polygon = generate_test_polygon(size, sharp_angle_ratio=0.05)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> algo_name, algo_func <span class="keywordflow">in</span> algorithms.items():</div>
<div class="line">        start_time = time.perf_counter()</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 运行检测</span></div>
<div class="line">        sharp_vertices = algo_func(test_polygon, threshold_degrees=30.0)</div>
<div class="line">        </div>
<div class="line">        end_time = time.perf_counter()</div>
<div class="line">        elapsed_ms = (end_time - start_time) * 1000</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;{size:&lt;10} {algo_name:&lt;15} {elapsed_ms:&lt;12.2f} {len(sharp_vertices):&lt;8}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 预期输出显示O(n)扩展</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md276"></a>
性能基准测试</h1>
<h2><a class="anchor" id="autotoc_md277"></a>
真实世界性能数据</h2>
<p><em>Intel i7-12700K，32GB RAM，-O3编译结果</em></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">多边形大小   </th><th class="markdownTableHeadNone">检测时间   </th><th class="markdownTableHeadNone">检测到的尖角   </th><th class="markdownTableHeadNone">内存使用    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100个顶点   </td><td class="markdownTableBodyNone">0.003 ms   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">2.4 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1,000个顶点   </td><td class="markdownTableBodyNone">0.025 ms   </td><td class="markdownTableBodyNone">48   </td><td class="markdownTableBodyNone">24 KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10,000个顶点   </td><td class="markdownTableBodyNone">0.234 ms   </td><td class="markdownTableBodyNone">467   </td><td class="markdownTableBodyNone">240 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100,000个顶点   </td><td class="markdownTableBodyNone">2.341 ms   </td><td class="markdownTableBodyNone">4,892   </td><td class="markdownTableBodyNone">2.4 MB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1,000,000个顶点   </td><td class="markdownTableBodyNone">23.7 ms   </td><td class="markdownTableBodyNone">49,203   </td><td class="markdownTableBodyNone">24 MB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md278"></a>
扩展性分析</h2>
<div class="fragment"><div class="line"><span class="comment"># 基准测试扩展行为</span></div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line">sizes = [100, 500, 1000, 5000, 10000, 50000, 100000]</div>
<div class="line">times_basic = [0.003, 0.012, 0.025, 0.117, 0.234, 1.167, 2.341]</div>
<div class="line">times_optimized = [0.002, 0.008, 0.018, 0.087, 0.178, 0.891, 1.823]</div>
<div class="line"> </div>
<div class="line">plt.figure(figsize=(10, 6))</div>
<div class="line">plt.loglog(sizes, times_basic, <span class="stringliteral">&#39;b-o&#39;</span>, label=<span class="stringliteral">&#39;基础算法&#39;</span>)</div>
<div class="line">plt.loglog(sizes, times_optimized, <span class="stringliteral">&#39;r-s&#39;</span>, label=<span class="stringliteral">&#39;优化算法&#39;</span>)</div>
<div class="line">plt.loglog(sizes, [0.000025 * n <span class="keywordflow">for</span> n <span class="keywordflow">in</span> sizes], <span class="stringliteral">&#39;g--&#39;</span>, label=<span class="stringliteral">&#39;O(n) 参考线&#39;</span>)</div>
<div class="line"> </div>
<div class="line">plt.xlabel(<span class="stringliteral">&#39;顶点数量&#39;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&#39;检测时间 (ms)&#39;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&#39;尖角检测性能扩展性&#39;</span>)</div>
<div class="line">plt.legend()</div>
<div class="line">plt.grid(<span class="keyword">True</span>, alpha=0.3)</div>
<div class="line">plt.show()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 线性相关系数</span></div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line">correlation = np.corrcoef(sizes, times_optimized)[0, 1]</div>
<div class="line">print(f<span class="stringliteral">&quot;线性相关系数: {correlation:.4f}&quot;</span>)</div>
<div class="line"><span class="comment"># 预期: &gt; 0.99，确认O(n)行为</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md280"></a>
空间索引优化</h1>
<h2><a class="anchor" id="autotoc_md281"></a>
何时使用空间索引</h2>
<p>对于包含许多组件的多多边形布局：</p>
<div class="fragment"><div class="line"><span class="comment"># 场景：包含10,000+组件的芯片布局</span></div>
<div class="line"><span class="keyword">class </span>OptimizedSharpAngleDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.spatial_index = <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds)</div>
<div class="line">        self.polygon_cache = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>batch_detect_sharp_angles(self, polygons, threshold_degrees=30.0):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;多多边形的优化检测&quot;&quot;&quot;</span></div>
<div class="line">        results = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 阶段1：构建空间索引</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            self.spatial_index.insert(bbox, poly_id)</div>
<div class="line">            self.polygon_cache[poly_id] = polygon</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 阶段2：利用空间局部性处理多边形</span></div>
<div class="line">        processed_regions = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            <span class="keywordflow">if</span> poly_id <span class="keywordflow">in</span> processed_regions:</div>
<div class="line">                <span class="keywordflow">continue</span></div>
<div class="line">                </div>
<div class="line">            <span class="comment"># 查找附近多边形</span></div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            expanded_bbox = bbox.expand(50.0)  <span class="comment"># 为局部性扩展</span></div>
<div class="line">            nearby_ids = self.spatial_index.query_range(expanded_bbox)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 一起处理这个区域</span></div>
<div class="line">            region_results = {}</div>
<div class="line">            <span class="keywordflow">for</span> nearby_id <span class="keywordflow">in</span> nearby_ids:</div>
<div class="line">                <span class="keywordflow">if</span> nearby_id <span class="keywordflow">not</span> <span class="keywordflow">in</span> processed_regions:</div>
<div class="line">                    nearby_polygon = self.polygon_cache[nearby_id]</div>
<div class="line">                    sharp_angles = self._detect_single_polygon(</div>
<div class="line">                        nearby_polygon, threshold_degrees</div>
<div class="line">                    )</div>
<div class="line">                    region_results[nearby_id] = sharp_angles</div>
<div class="line">                    processed_regions.add(nearby_id)</div>
<div class="line">            </div>
<div class="line">            results.update(region_results)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 性能比较</span></div>
<div class="line">large_layout_polygons = generate_chip_layout(num_components=10000)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 方法1：朴素方法</span></div>
<div class="line">start_time = time.perf_counter()</div>
<div class="line">naive_results = []</div>
<div class="line"><span class="keywordflow">for</span> polygon <span class="keywordflow">in</span> large_layout_polygons:</div>
<div class="line">    sharp_angles = detector.detect_sharp_angles(polygon.vertices)</div>
<div class="line">    naive_results.append(sharp_angles)</div>
<div class="line">naive_time = time.perf_counter() - start_time</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 方法2：空间优化</span></div>
<div class="line">start_time = time.perf_counter()</div>
<div class="line">optimized_detector = OptimizedSharpAngleDetector(world_bounds)</div>
<div class="line">optimized_results = optimized_detector.batch_detect_sharp_angles(</div>
<div class="line">    large_layout_polygons</div>
<div class="line">)</div>
<div class="line">optimized_time = time.perf_counter() - start_time</div>
<div class="line"> </div>
<div class="line">speedup = naive_time / optimized_time</div>
<div class="line">print(f<span class="stringliteral">&quot;加速比: {speedup:.2f}x&quot;</span>)</div>
<div class="line"><span class="comment"># 预期：由于更好的缓存局部性，加速2-4倍</span></div>
<div class="ttc" id="aclasszlayout_1_1spatial_1_1_quad_tree_html"><div class="ttname"><a href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout::spatial::QuadTree</a></div><div class="ttdoc">Quadtree spatial index for efficient range and intersection queries.</div><div class="ttdef"><b>Definition</b> <a href="quadtree_8hpp_source.html#l00120">quadtree.hpp:120</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md282"></a>
内存访问模式</h2>
<div class="fragment"><div class="line"><span class="comment"># 内存访问模式分析</span></div>
<div class="line"><span class="keyword">import</span> psutil</div>
<div class="line"><span class="keyword">import</span> os</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>monitor_memory_usage(func, *args, **kwargs):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;在函数执行期间监控内存使用&quot;&quot;&quot;</span></div>
<div class="line">    process = psutil.Process(os.getpid())</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 基线内存</span></div>
<div class="line">    mem_before = process.memory_info().rss / 1024 / 1024  <span class="comment"># MB</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 执行函数</span></div>
<div class="line">    result = func(*args, **kwargs)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 峰值内存</span></div>
<div class="line">    mem_after = process.memory_info().rss / 1024 / 1024  <span class="comment"># MB</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> result, mem_after - mem_before</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 比较内存使用模式</span></div>
<div class="line">test_polygon = generate_test_polygon(100000)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 顺序访问模式</span></div>
<div class="line">result1, mem_usage1 = monitor_memory_usage(</div>
<div class="line">    detector.detect_sharp_angles, test_polygon</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 批处理模式</span></div>
<div class="line">result2, mem_usage2 = monitor_memory_usage(</div>
<div class="line">    detector.batch_detect_sharp_angles, [test_polygon] * 100</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;顺序处理: {mem_usage1:.1f} MB&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;批处理: {mem_usage2:.1f} MB&quot;</span>) </div>
<div class="line">print(f<span class="stringliteral">&quot;内存效率: {mem_usage1/mem_usage2:.2f}x&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md284"></a>
实际应用</h1>
<h2><a class="anchor" id="autotoc_md285"></a>
1. ASIC设计规则检查</h2>
<div class="fragment"><div class="line"><span class="comment"># 示例：7nm工艺节点验证</span></div>
<div class="line"><span class="keyword">def </span>validate_asic_layout(layout_file, process_node=&quot;7nm&quot;):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;根据工艺规则验证ASIC布局&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    process_rules = {</div>
<div class="line">        <span class="stringliteral">&quot;7nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 20.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.014},  <span class="comment"># 14nm间距</span></div>
<div class="line">        <span class="stringliteral">&quot;5nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 15.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.010},  <span class="comment"># 10nm间距</span></div>
<div class="line">        <span class="stringliteral">&quot;3nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 12.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.008},  <span class="comment"># 8nm间距</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    rules = process_rules[process_node]</div>
<div class="line">    layout = zlayout.load_layout(layout_file)</div>
<div class="line">    </div>
<div class="line">    violation_report = {</div>
<div class="line">        <span class="stringliteral">&quot;sharp_angles&quot;</span>: [],</div>
<div class="line">        <span class="stringliteral">&quot;spacing_violations&quot;</span>: [],</div>
<div class="line">        <span class="stringliteral">&quot;total_components&quot;</span>: len(layout.components)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 检查每个组件</span></div>
<div class="line">    <span class="keywordflow">for</span> comp_id, component <span class="keywordflow">in</span> enumerate(layout.components):</div>
<div class="line">        <span class="comment"># 尖角检查</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            component.geometry.vertices,</div>
<div class="line">            threshold_degrees=rules[<span class="stringliteral">&quot;min_angle&quot;</span>]</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> sharp_angles:</div>
<div class="line">            violation_report[<span class="stringliteral">&quot;sharp_angles&quot;</span>].append({</div>
<div class="line">                <span class="stringliteral">&quot;component_id&quot;</span>: comp_id,</div>
<div class="line">                <span class="stringliteral">&quot;component_name&quot;</span>: component.name,</div>
<div class="line">                <span class="stringliteral">&quot;violating_vertices&quot;</span>: sharp_angles,</div>
<div class="line">                <span class="stringliteral">&quot;severity&quot;</span>: <span class="stringliteral">&quot;严重&quot;</span> <span class="keywordflow">if</span> min([</div>
<div class="line">                    detector.calculate_vertex_angle(component.geometry.vertices, i) </div>
<div class="line">                    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sharp_angles</div>
<div class="line">                ]) &lt; rules[<span class="stringliteral">&quot;min_angle&quot;</span>] * 0.5 <span class="keywordflow">else</span> <span class="stringliteral">&quot;警告&quot;</span></div>
<div class="line">            })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> violation_report</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 使用示例</span></div>
<div class="line">report = validate_asic_layout(<span class="stringliteral">&quot;cpu_core_layout.gds&quot;</span>, <span class="stringliteral">&quot;7nm&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;发现 {len(report[&#39;sharp_angles&#39;])} 个组件有尖角违规&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 生成详细报告</span></div>
<div class="line"><span class="keywordflow">for</span> violation <span class="keywordflow">in</span> report[<span class="stringliteral">&quot;sharp_angles&quot;</span>]:</div>
<div class="line">    <span class="keywordflow">if</span> violation[<span class="stringliteral">&quot;severity&quot;</span>] == <span class="stringliteral">&quot;严重&quot;</span>:</div>
<div class="line">        print(f<span class="stringliteral">&quot;严重: {violation[&#39;component_name&#39;]} 有严重尖角&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md286"></a>
2. PCB布局优化</h2>
<div class="fragment"><div class="line"><span class="comment"># PCB走线制造优化</span></div>
<div class="line"><span class="keyword">def </span>optimize_pcb_traces(pcb_layout, target_impedance=50.0):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;在避免尖角的同时优化PCB走线&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    optimized_traces = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> trace <span class="keywordflow">in</span> pcb_layout.traces:</div>
<div class="line">        <span class="comment"># 检测走线路径中的尖角</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            trace.path_vertices, </div>
<div class="line">            threshold_degrees=30.0  <span class="comment"># PCB制造限制</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> sharp_angles:</div>
<div class="line">            <span class="comment"># 应用倒角</span></div>
<div class="line">            optimized_path = round_sharp_corners(</div>
<div class="line">                trace.path_vertices, </div>
<div class="line">                sharp_angle_indices=sharp_angles,</div>
<div class="line">                radius=0.1  <span class="comment"># 0.1mm倒角半径</span></div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 验证阻抗是否保持</span></div>
<div class="line">            new_impedance = calculate_trace_impedance(optimized_path, trace.width)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> abs(new_impedance - target_impedance) &lt; 2.0:  <span class="comment"># 2欧姆容差</span></div>
<div class="line">                optimized_traces.append(Trace(optimized_path, trace.width))</div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># 调整走线宽度以维持阻抗</span></div>
<div class="line">                adjusted_width = adjust_width_for_impedance(</div>
<div class="line">                    optimized_path, target_impedance</div>
<div class="line">                )</div>
<div class="line">                optimized_traces.append(Trace(optimized_path, adjusted_width))</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            optimized_traces.append(trace)  <span class="comment"># 无需更改</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> optimized_traces</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md287"></a>
3. MEMS器件设计</h2>
<div class="fragment"><div class="line"><span class="comment"># 微机电系统(MEMS)设计验证</span></div>
<div class="line"><span class="keyword">def </span>validate_mems_design(mems_structure, material_properties):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;验证MEMS设计的应力集中&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    stress_analysis = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> component <span class="keywordflow">in</span> mems_structure.mechanical_components:</div>
<div class="line">        <span class="comment"># 检测可能导致应力集中的尖角</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            component.geometry.vertices,</div>
<div class="line">            threshold_degrees=45.0  <span class="comment"># MEMS通常需要更柔和的角度</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> angle_idx <span class="keywordflow">in</span> sharp_angles:</div>
<div class="line">            angle_value = detector.calculate_vertex_angle(</div>
<div class="line">                component.geometry.vertices, angle_idx</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># 计算应力集中因子</span></div>
<div class="line">            stress_factor = calculate_stress_concentration(</div>
<div class="line">                angle_value, material_properties</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> stress_factor &gt; 3.0:  <span class="comment"># 临界阈值</span></div>
<div class="line">                stress_analysis.append({</div>
<div class="line">                    <span class="stringliteral">&quot;component&quot;</span>: component.name,</div>
<div class="line">                    <span class="stringliteral">&quot;vertex&quot;</span>: angle_idx,</div>
<div class="line">                    <span class="stringliteral">&quot;angle&quot;</span>: angle_value,</div>
<div class="line">                    <span class="stringliteral">&quot;stress_factor&quot;</span>: stress_factor,</div>
<div class="line">                    <span class="stringliteral">&quot;recommendation&quot;</span>: f<span class="stringliteral">&quot;使用半径 ≥ {0.5 * component.thickness:.3f}μm 的倒角&quot;</span></div>
<div class="line">                })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> stress_analysis</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md289"></a>
高级主题</h1>
<h2><a class="anchor" id="autotoc_md290"></a>
数值稳定性</h2>
<div class="fragment"><div class="line"><span class="comment"># 处理边缘情况和数值精度</span></div>
<div class="line"><span class="keyword">class </span>NumericallyStableDetector:</div>
<div class="line">    EPSILON = 1e-12</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>safe_acos(value):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;数值稳定的反余弦计算&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 限制到有效域[-1, 1]</span></div>
<div class="line">        clamped = max(-1.0, min(1.0, value))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 在边界附近使用替代公式</span></div>
<div class="line">        <span class="keywordflow">if</span> abs(clamped) &gt; 0.99999:</div>
<div class="line">            <span class="keywordflow">if</span> clamped &gt; 0:</div>
<div class="line">                <span class="keywordflow">return</span> math.sqrt(2 * (1 - clamped))  <span class="comment"># 接近0度</span></div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="keywordflow">return</span> math.pi - math.sqrt(2 * (1 + clamped))  <span class="comment"># 接近180度</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> math.acos(clamped)</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@classmethod</span>  </div>
<div class="line">    <span class="keyword">def </span>robust_angle_calculation(cls, v1, v2):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;具有数值稳定性的向量间角度计算&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 计算模长</span></div>
<div class="line">        mag1 = math.sqrt(v1[0]**2 + v1[1]**2)</div>
<div class="line">        mag2 = math.sqrt(v2[0]**2 + v2[1]**2)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 检查退化向量</span></div>
<div class="line">        <span class="keywordflow">if</span> mag1 &lt; cls.EPSILON <span class="keywordflow">or</span> mag2 &lt; cls.EPSILON:</div>
<div class="line">            <span class="keywordflow">return</span> float(<span class="stringliteral">&#39;nan&#39;</span>)  <span class="comment"># 未定义角度</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 标准化向量</span></div>
<div class="line">        n1 = (v1[0] / mag1, v1[1] / mag1)</div>
<div class="line">        n2 = (v2[0] / mag2, v2[1] / mag2)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># 使用atan2提高数值稳定性</span></div>
<div class="line">        cross_product = n1[0] * n2[1] - n1[1] * n2[0]</div>
<div class="line">        dot_product = n1[0] * n2[0] + n1[1] * n2[1]</div>
<div class="line">        </div>
<div class="line">        angle_rad = math.atan2(abs(cross_product), dot_product)</div>
<div class="line">        <span class="keywordflow">return</span> math.degrees(angle_rad)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md292"></a>
总结</h1>
<p>尖角检测是EDA中的基础算法，具有**O(n)时间复杂度**，在ASIC、PCB和MEMS设计中有广泛应用。要点总结：</p>
<p><b>算法效率：</b></p><ul>
<li>每个多边形线性时间复杂度O(n)</li>
<li>处理的常数空间复杂度O(1)</li>
<li>大数据集的出色缓存局部性</li>
</ul>
<p><b>优化策略：</b></p><ul>
<li>使用<code>atan2</code>而非<code>acos</code>提高数值稳定性</li>
<li>批处理提高内存效率</li>
<li>多多边形布局使用空间索引</li>
</ul>
<p><b>实际影响：</b></p><ul>
<li>设计规则检查(DRC)的核心</li>
<li>制造可行性的关键</li>
<li>防止MEMS器件应力集中</li>
</ul>
<p><b>性能特征：</b></p><ul>
<li>随多边形复杂度线性扩展</li>
<li>可实现内存高效实现</li>
<li>适用于实时应用</li>
</ul>
<p>在生产使用中，将稳健的角度计算与空间索引结合，可在大规模EDA布局上获得最佳性能。 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
