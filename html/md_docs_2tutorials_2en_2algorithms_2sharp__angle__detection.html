<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZLayout EDA Library: Sharp Angle Detection Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZLayout EDA Library<span id="projectnumber">&#160;v1.0.0</span>
   </div>
   <div id="projectbrief">Advanced Electronic Design Automation Layout Library with Bilingual Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2tutorials_2en_2algorithms_2sharp__angle__detection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sharp Angle Detection Algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md83"></a> <em>Essential for Design Rule Checking (DRC) in EDA workflows</em></p>
<h1><a class="anchor" id="autotoc_md84"></a>
Overview</h1>
<p>Sharp angle detection is a fundamental geometric analysis algorithm used extensively in electronic design automation. It identifies vertices in polygons where the interior angle is below a specified threshold, which is crucial for manufacturing feasibility and design rule checking.</p>
<h1><a class="anchor" id="autotoc_md85"></a>
Table of Contents</h1>
<ol type="1">
<li>Problem Definition</li>
<li>Algorithm Theory</li>
<li>Implementation Approaches</li>
<li>Complexity Analysis</li>
<li>Interactive Tutorial</li>
<li>Performance Benchmarks</li>
<li>Spatial Index Optimization</li>
<li>Real-world Applications</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md87"></a>
Problem Definition</h1>
<h2><a class="anchor" id="autotoc_md88"></a>
What are Sharp Angles?</h2>
<p>In EDA layouts, sharp angles pose manufacturing challenges:</p>
<ul>
<li><b>Etching Problems</b>: Sharp corners can cause over-etching or under-etching</li>
<li><b>Stress Concentration</b>: Sharp angles create mechanical stress points</li>
<li><b>Process Variations</b>: Manufacturing tolerances affect sharp features more severely</li>
</ul>
<h2><a class="anchor" id="autotoc_md89"></a>
Mathematical Definition</h2>
<p>For a polygon vertex at position <code>P</code> with adjacent vertices <code>P_prev</code> and <code>P_next</code>:</p>
<div class="fragment"><div class="line">Interior Angle θ = arccos((v1 · v2) / (|v1| × |v2|))</div>
<div class="line"> </div>
<div class="line">where:</div>
<div class="line">v1 = P_prev - P</div>
<div class="line">v2 = P_next - P</div>
</div><!-- fragment --><p>An angle is considered "sharp" if θ &lt; threshold (typically 30° to 60°).</p>
<hr  />
<h1><a class="anchor" id="autotoc_md91"></a>
Algorithm Theory</h1>
<h2><a class="anchor" id="autotoc_md92"></a>
Core Algorithm Steps</h2>
<ol type="1">
<li><b>Iterate through vertices</b> of the polygon</li>
<li><b>Calculate vectors</b> from current vertex to adjacent vertices</li>
<li><b>Compute dot product</b> and magnitudes</li>
<li><b>Calculate angle</b> using inverse cosine</li>
<li><b>Compare with threshold</b> and collect violations</li>
</ol>
<h2><a class="anchor" id="autotoc_md93"></a>
Edge Cases Handling</h2>
<ul>
<li><b>Collinear vertices</b> (angle = 180°)</li>
<li><b>Self-intersecting polygons</b></li>
<li><b>Degenerate triangles</b> (area ≈ 0)</li>
<li><b>Numerical precision</b> issues</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md95"></a>
Implementation Approaches</h1>
<h2><a class="anchor" id="autotoc_md96"></a>
Approach 1: Basic Vector Mathematics</h2>
<div class="fragment"><div class="line"><span class="comment">// C++ Implementation</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">    <span class="keywordtype">double</span> x, y;</div>
<div class="line">    Point(<span class="keywordtype">double</span> x = 0, <span class="keywordtype">double</span> y = 0) : x(x), y(y) {}</div>
<div class="line">    Point operator-(<span class="keyword">const</span> Point&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> Point(x - other.x, y - other.y);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharpAngleDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;int&gt; detectSharpAngles(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, </div>
<div class="line">        <span class="keywordtype">double</span> threshold_degrees = 30.0</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;int&gt; sharp_vertices;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> threshold_rad = threshold_degrees * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 180.0;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            <span class="comment">// Get three consecutive vertices</span></div>
<div class="line">            <span class="keyword">const</span> Point&amp; prev = vertices[(i - 1 + n) % n];</div>
<div class="line">            <span class="keyword">const</span> Point&amp; curr = vertices[i];</div>
<div class="line">            <span class="keyword">const</span> Point&amp; next = vertices[(i + 1) % n];</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Calculate vectors from current vertex</span></div>
<div class="line">            Point v1 = prev - curr;</div>
<div class="line">            Point v2 = next - curr;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Calculate magnitudes</span></div>
<div class="line">            <span class="keywordtype">double</span> mag1 = sqrt(v1.x * v1.x + v1.y * v1.y);</div>
<div class="line">            <span class="keywordtype">double</span> mag2 = sqrt(v2.x * v2.x + v2.y * v2.y);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Avoid division by zero</span></div>
<div class="line">            <span class="keywordflow">if</span> (mag1 &lt; 1e-10 || mag2 &lt; 1e-10) <span class="keywordflow">continue</span>;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Calculate dot product and angle</span></div>
<div class="line">            <span class="keywordtype">double</span> dot_product = v1.x * v2.x + v1.y * v2.y;</div>
<div class="line">            <span class="keywordtype">double</span> cos_angle = dot_product / (mag1 * mag2);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Clamp to valid range for acos</span></div>
<div class="line">            cos_angle = std::max(-1.0, std::min(1.0, cos_angle));</div>
<div class="line">            <span class="keywordtype">double</span> angle = acos(cos_angle);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Check if angle is sharp</span></div>
<div class="line">            <span class="keywordflow">if</span> (angle &lt; threshold_rad) {</div>
<div class="line">                sharp_vertices.push_back(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="apolygon_8cpp_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdef"><b>Definition</b> <a href="polygon_8cpp_source.html#l00015">polygon.cpp:15</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md97"></a>
Approach 2: Cross Product Method (More Robust)</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RobustSharpAngleDetector {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::vector&lt;int&gt; detectSharpAngles(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, </div>
<div class="line">        <span class="keywordtype">double</span> threshold_degrees = 30.0</div>
<div class="line">    ) {</div>
<div class="line">        std::vector&lt;int&gt; sharp_vertices;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            <span class="keywordtype">double</span> angle = calculateInteriorAngle(vertices, i);</div>
<div class="line">            <span class="keywordflow">if</span> (angle &lt; threshold_degrees &amp;&amp; angle &gt; 0) {</div>
<div class="line">                sharp_vertices.push_back(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">double</span> calculateInteriorAngle(<span class="keyword">const</span> std::vector&lt;Point&gt;&amp; vertices, <span class="keywordtype">int</span> index) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> n = vertices.size();</div>
<div class="line">        <span class="keyword">const</span> Point&amp; prev = vertices[(index - 1 + n) % n];</div>
<div class="line">        <span class="keyword">const</span> Point&amp; curr = vertices[index];</div>
<div class="line">        <span class="keyword">const</span> Point&amp; next = vertices[(index + 1) % n];</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Use atan2 for better numerical stability</span></div>
<div class="line">        <span class="keywordtype">double</span> angle1 = atan2(prev.y - curr.y, prev.x - curr.x);</div>
<div class="line">        <span class="keywordtype">double</span> angle2 = atan2(next.y - curr.y, next.x - curr.x);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> angle_diff = angle2 - angle1;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Normalize to [0, 2π]</span></div>
<div class="line">        <span class="keywordflow">while</span> (angle_diff &lt; 0) angle_diff += 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        <span class="keywordflow">while</span> (angle_diff &gt; 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>) angle_diff -= 2 * <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Convert to degrees and handle convex/concave</span></div>
<div class="line">        <span class="keywordtype">double</span> interior_angle = angle_diff * 180.0 / <a class="code hl_define" href="polygon_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>;</div>
<div class="line">        <span class="keywordflow">if</span> (interior_angle &gt; 180.0) {</div>
<div class="line">            interior_angle = 360.0 - interior_angle;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> interior_angle;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md98"></a>
Python Implementation</h2>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> math</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Tuple</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharpAngleDetector:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;High-performance sharp angle detection for EDA layouts.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>detect_sharp_angles(vertices: List[Tuple[float, float]], </div>
<div class="line">                          threshold_degrees: float = 30.0) -&gt; List[int]:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Detect vertices with sharp angles below threshold.</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            vertices: List of (x, y) coordinate tuples</span></div>
<div class="line"><span class="stringliteral">            threshold_degrees: Angle threshold in degrees</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        Returns:</span></div>
<div class="line"><span class="stringliteral">            List of vertex indices with sharp angles</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        sharp_vertices = []</div>
<div class="line">        n = len(vertices)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> n &lt; 3:</div>
<div class="line">            <span class="keywordflow">return</span> sharp_vertices</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line">            <span class="comment"># Get three consecutive vertices</span></div>
<div class="line">            prev_vertex = vertices[(i - 1) % n]</div>
<div class="line">            curr_vertex = vertices[i]</div>
<div class="line">            next_vertex = vertices[(i + 1) % n]</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Calculate interior angle</span></div>
<div class="line">            angle = SharpAngleDetector._calculate_interior_angle(</div>
<div class="line">                prev_vertex, curr_vertex, next_vertex</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> 0 &lt; angle &lt; threshold_degrees:</div>
<div class="line">                sharp_vertices.append(i)</div>
<div class="line">                </div>
<div class="line">        <span class="keywordflow">return</span> sharp_vertices</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>_calculate_interior_angle(prev_pt: Tuple[float, float], </div>
<div class="line">                                curr_pt: Tuple[float, float], </div>
<div class="line">                                next_pt: Tuple[float, float]) -&gt; float:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Calculate interior angle at current vertex using atan2.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Vectors from current point to adjacent points</span></div>
<div class="line">        v1 = (prev_pt[0] - curr_pt[0], prev_pt[1] - curr_pt[1])</div>
<div class="line">        v2 = (next_pt[0] - curr_pt[0], next_pt[1] - curr_pt[1])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Calculate angles using atan2 for numerical stability</span></div>
<div class="line">        angle1 = math.atan2(v1[1], v1[0])</div>
<div class="line">        angle2 = math.atan2(v2[1], v2[0])</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Calculate interior angle</span></div>
<div class="line">        angle_diff = angle2 - angle1</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Normalize to [0, 2π]</span></div>
<div class="line">        <span class="keywordflow">while</span> angle_diff &lt; 0:</div>
<div class="line">            angle_diff += 2 * math.pi</div>
<div class="line">        <span class="keywordflow">while</span> angle_diff &gt; 2 * math.pi:</div>
<div class="line">            angle_diff -= 2 * math.pi</div>
<div class="line">            </div>
<div class="line">        <span class="comment"># Convert to degrees</span></div>
<div class="line">        interior_angle = math.degrees(angle_diff)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Handle convex polygons (interior angles &lt; 180°)</span></div>
<div class="line">        <span class="keywordflow">if</span> interior_angle &gt; 180:</div>
<div class="line">            interior_angle = 360 - interior_angle</div>
<div class="line">            </div>
<div class="line">        <span class="keywordflow">return</span> interior_angle</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md100"></a>
Complexity Analysis</h1>
<h2><a class="anchor" id="autotoc_md101"></a>
Time Complexity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Implementation   </th><th class="markdownTableHeadNone">Best Case   </th><th class="markdownTableHeadNone">Average Case   </th><th class="markdownTableHeadNone">Worst Case   </th><th class="markdownTableHeadNone">Space    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Basic Algorithm   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">With Spatial Index   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Batch Processing   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(kn)   </td><td class="markdownTableBodyNone">O(k)   </td></tr>
</table>
<p>Where:</p><ul>
<li><code>n</code> = number of vertices in polygon</li>
<li><code>k</code> = number of polygons</li>
</ul>
<h2><a class="anchor" id="autotoc_md102"></a>
Detailed Analysis</h2>
<p><b>Single Polygon Analysis:</b> </p><div class="fragment"><div class="line">For each vertex (n iterations):</div>
<div class="line">  - Vector calculation: O(1)</div>
<div class="line">  - Dot product: O(1)  </div>
<div class="line">  - Magnitude calculation: O(1)</div>
<div class="line">  - Angle calculation: O(1)</div>
<div class="line">  </div>
<div class="line">Total: O(n) per polygon</div>
</div><!-- fragment --><p><b>Multi-Polygon Analysis:</b> </p><div class="fragment"><div class="line">For k polygons with average n vertices:</div>
<div class="line">  - Naive approach: O(k × n)</div>
<div class="line">  - With spatial indexing: O(k × n) [same complexity, but better constants]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Memory Complexity</h2>
<ul>
<li><b>Input</b>: O(n) for vertex storage</li>
<li><b>Output</b>: O(s) where s ≤ n is the number of sharp angles</li>
<li><b>Working memory</b>: O(1) for calculations</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md105"></a>
Interactive Tutorial</h1>
<h2><a class="anchor" id="autotoc_md106"></a>
Tutorial 1: Basic Sharp Angle Detection</h2>
<div class="fragment"><div class="line"><span class="comment"># Let&#39;s start with a simple example</span></div>
<div class="line"><span class="keyword">import</span> zlayout</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a polygon with known sharp angles</span></div>
<div class="line">vertices = [</div>
<div class="line">    (0.0, 0.0),    <span class="comment"># Regular vertex</span></div>
<div class="line">    (10.0, 0.0),   <span class="comment"># Regular vertex  </span></div>
<div class="line">    (5.0, 1.0),    <span class="comment"># Sharp angle! (Very acute triangle)</span></div>
<div class="line">    (2.0, 8.0),    <span class="comment"># Regular vertex</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">polygon = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>(vertices)</div>
<div class="line">detector = zlayout.SharpAngleDetector()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Detect sharp angles with 45° threshold</span></div>
<div class="line">sharp_indices = detector.detect_sharp_angles(polygon.vertices, threshold_degrees=45.0)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Sharp angle vertices: {sharp_indices}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected output: [2] (the acute triangle vertex)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Calculate actual angles for verification</span></div>
<div class="line"><span class="keywordflow">for</span> i, vertex <span class="keywordflow">in</span> enumerate(polygon.vertices):</div>
<div class="line">    angle = detector.calculate_vertex_angle(polygon.vertices, i)</div>
<div class="line">    marker = <span class="stringliteral">&quot; &lt;- SHARP!&quot;</span> <span class="keywordflow">if</span> i <span class="keywordflow">in</span> sharp_indices <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Vertex {i}: {angle:.1f}°{marker}&quot;</span>)</div>
<div class="ttc" id="aclasszlayout_1_1geometry_1_1_polygon_html"><div class="ttname"><a href="classzlayout_1_1geometry_1_1_polygon.html">zlayout::geometry::Polygon</a></div><div class="ttdoc">Polygon class supporting both convex and concave polygons.</div><div class="ttdef"><b>Definition</b> <a href="polygon_8hpp_source.html#l00025">polygon.hpp:25</a></div></div>
</div><!-- fragment --><p><b>Expected Output:</b> </p><div class="fragment"><div class="line">Sharp angle vertices: [2]</div>
<div class="line">Vertex 0: 168.7°</div>
<div class="line">Vertex 1: 163.1° </div>
<div class="line">Vertex 2: 11.3° &lt;- SHARP!</div>
<div class="line">Vertex 3: 116.9°</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
Tutorial 2: Manufacturing Process Validation</h2>
<div class="fragment"><div class="line"><span class="comment"># Simulate different manufacturing processes</span></div>
<div class="line">process_rules = {</div>
<div class="line">    <span class="stringliteral">&quot;28nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 45.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;28nm process node&quot;</span>},</div>
<div class="line">    <span class="stringliteral">&quot;14nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 30.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;14nm process node&quot;</span>},  </div>
<div class="line">    <span class="stringliteral">&quot;7nm&quot;</span>:  {<span class="stringliteral">&quot;min_angle&quot;</span>: 20.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;7nm process node&quot;</span>},</div>
<div class="line">    <span class="stringliteral">&quot;3nm&quot;</span>:  {<span class="stringliteral">&quot;min_angle&quot;</span>: 15.0, <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;3nm process node&quot;</span>},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Test polygon from a real CPU layout (simplified)</span></div>
<div class="line">cpu_components = [</div>
<div class="line">    <span class="comment"># ALU component outline</span></div>
<div class="line">    [(0, 0), (100, 0), (100, 80), (95, 85), (0, 80)],</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Cache line with potential sharp corner</span></div>
<div class="line">    [(150, 10), (250, 10), (250, 70), (240, 75), (140, 70), (140, 15)],</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Critical timing path with tight constraints</span></div>
<div class="line">    [(300, 20), (320, 22), (302, 45), (285, 40)]  <span class="comment"># Very sharp angle</span></div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> process_name, rules <span class="keywordflow">in</span> process_rules.items():</div>
<div class="line">    print(f<span class="stringliteral">&quot;\n=== {rules[&#39;description&#39;]} ===&quot;</span>)</div>
<div class="line">    total_violations = 0</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> i, component_vertices <span class="keywordflow">in</span> enumerate(cpu_components):</div>
<div class="line">        polygon = <a class="code hl_class" href="classzlayout_1_1geometry_1_1_polygon.html">zlayout.Polygon</a>(component_vertices)</div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            polygon.vertices, </div>
<div class="line">            threshold_degrees=rules[<span class="stringliteral">&#39;min_angle&#39;</span>]</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        violations = len(sharp_angles)</div>
<div class="line">        total_violations += violations</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;Component {i+1}: {violations} violations&quot;</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Show specific angles that violate rules</span></div>
<div class="line">        <span class="keywordflow">for</span> vertex_idx <span class="keywordflow">in</span> sharp_angles:</div>
<div class="line">            angle = detector.calculate_vertex_angle(polygon.vertices, vertex_idx)</div>
<div class="line">            print(f<span class="stringliteral">&quot;  Vertex {vertex_idx}: {angle:.1f}° &lt; {rules[&#39;min_angle&#39;]}°&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    status = <span class="stringliteral">&quot;PASS&quot;</span> <span class="keywordflow">if</span> total_violations == 0 <span class="keywordflow">else</span> f<span class="stringliteral">&quot;FAIL ({total_violations} violations)&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Process validation: {status}&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md108"></a>
Tutorial 3: Performance Optimization</h2>
<div class="fragment"><div class="line"><span class="comment"># Benchmark different detection algorithms</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> random</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_test_polygon(num_vertices, sharp_angle_ratio=0.1):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Generate polygon with controlled sharp angles for testing.&quot;&quot;&quot;</span></div>
<div class="line">    vertices = []</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Generate points on a rough circle</span></div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(num_vertices):</div>
<div class="line">        angle = 2 * math.pi * i / num_vertices</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Add some randomness</span></div>
<div class="line">        radius = 50 + random.uniform(-10, 10)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Occasionally create sharp angles</span></div>
<div class="line">        <span class="keywordflow">if</span> random.random() &lt; sharp_angle_ratio:</div>
<div class="line">            radius *= 0.3  <span class="comment"># Pull vertex inward to create sharp angle</span></div>
<div class="line">            </div>
<div class="line">        x = radius * math.cos(angle)</div>
<div class="line">        y = radius * math.sin(angle)</div>
<div class="line">        vertices.append((x, y))</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> vertices</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Performance comparison</span></div>
<div class="line">test_sizes = [100, 1000, 10000, 100000]</div>
<div class="line">algorithms = {</div>
<div class="line">    <span class="stringliteral">&quot;Basic Vector&quot;</span>: detector.detect_sharp_angles_basic,</div>
<div class="line">    <span class="stringliteral">&quot;Robust atan2&quot;</span>: detector.detect_sharp_angles_robust,</div>
<div class="line">    <span class="stringliteral">&quot;NumPy Vectorized&quot;</span>: detector.detect_sharp_angles_numpy</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Performance Comparison (Sharp Angle Detection)&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;-&quot;</span> * 60)</div>
<div class="line">print(f<span class="stringliteral">&quot;{&#39;Vertices&#39;:&lt;10} {&#39;Algorithm&#39;:&lt;15} {&#39;Time (ms)&#39;:&lt;12} {&#39;Found&#39;:&lt;8}&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;-&quot;</span> * 60)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> size <span class="keywordflow">in</span> test_sizes:</div>
<div class="line">    test_polygon = generate_test_polygon(size, sharp_angle_ratio=0.05)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> algo_name, algo_func <span class="keywordflow">in</span> algorithms.items():</div>
<div class="line">        start_time = time.perf_counter()</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Run detection</span></div>
<div class="line">        sharp_vertices = algo_func(test_polygon, threshold_degrees=30.0)</div>
<div class="line">        </div>
<div class="line">        end_time = time.perf_counter()</div>
<div class="line">        elapsed_ms = (end_time - start_time) * 1000</div>
<div class="line">        </div>
<div class="line">        print(f<span class="stringliteral">&quot;{size:&lt;10} {algo_name:&lt;15} {elapsed_ms:&lt;12.2f} {len(sharp_vertices):&lt;8}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Expected output shows O(n) scaling</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md110"></a>
Performance Benchmarks</h1>
<h2><a class="anchor" id="autotoc_md111"></a>
Real-world Performance Data</h2>
<p><em>Results from Intel i7-12700K, 32GB RAM, compiled with -O3</em></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Polygon Size   </th><th class="markdownTableHeadNone">Detection Time   </th><th class="markdownTableHeadNone">Sharp Angles Found   </th><th class="markdownTableHeadNone">Memory Usage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100 vertices   </td><td class="markdownTableBodyNone">0.003 ms   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">2.4 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1,000 vertices   </td><td class="markdownTableBodyNone">0.025 ms   </td><td class="markdownTableBodyNone">48   </td><td class="markdownTableBodyNone">24 KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10,000 vertices   </td><td class="markdownTableBodyNone">0.234 ms   </td><td class="markdownTableBodyNone">467   </td><td class="markdownTableBodyNone">240 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100,000 vertices   </td><td class="markdownTableBodyNone">2.341 ms   </td><td class="markdownTableBodyNone">4,892   </td><td class="markdownTableBodyNone">2.4 MB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1,000,000 vertices   </td><td class="markdownTableBodyNone">23.7 ms   </td><td class="markdownTableBodyNone">49,203   </td><td class="markdownTableBodyNone">24 MB   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md112"></a>
Scaling Analysis</h2>
<div class="fragment"><div class="line"><span class="comment"># Benchmark scaling behavior</span></div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line">sizes = [100, 500, 1000, 5000, 10000, 50000, 100000]</div>
<div class="line">times_basic = [0.003, 0.012, 0.025, 0.117, 0.234, 1.167, 2.341]</div>
<div class="line">times_optimized = [0.002, 0.008, 0.018, 0.087, 0.178, 0.891, 1.823]</div>
<div class="line"> </div>
<div class="line">plt.figure(figsize=(10, 6))</div>
<div class="line">plt.loglog(sizes, times_basic, <span class="stringliteral">&#39;b-o&#39;</span>, label=<span class="stringliteral">&#39;Basic Algorithm&#39;</span>)</div>
<div class="line">plt.loglog(sizes, times_optimized, <span class="stringliteral">&#39;r-s&#39;</span>, label=<span class="stringliteral">&#39;Optimized Algorithm&#39;</span>)</div>
<div class="line">plt.loglog(sizes, [0.000025 * n <span class="keywordflow">for</span> n <span class="keywordflow">in</span> sizes], <span class="stringliteral">&#39;g--&#39;</span>, label=<span class="stringliteral">&#39;O(n) Reference&#39;</span>)</div>
<div class="line"> </div>
<div class="line">plt.xlabel(<span class="stringliteral">&#39;Number of Vertices&#39;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&#39;Detection Time (ms)&#39;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&#39;Sharp Angle Detection Performance Scaling&#39;</span>)</div>
<div class="line">plt.legend()</div>
<div class="line">plt.grid(<span class="keyword">True</span>, alpha=0.3)</div>
<div class="line">plt.show()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Linear correlation coefficient</span></div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line">correlation = np.corrcoef(sizes, times_optimized)[0, 1]</div>
<div class="line">print(f<span class="stringliteral">&quot;Linear correlation coefficient: {correlation:.4f}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected: &gt; 0.99, confirming O(n) behavior</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md114"></a>
Spatial Index Optimization</h1>
<h2><a class="anchor" id="autotoc_md115"></a>
When to Use Spatial Indexing</h2>
<p>For multi-polygon layouts with many components:</p>
<div class="fragment"><div class="line"><span class="comment"># Scenario: Chip layout with 10,000+ components</span></div>
<div class="line"><span class="keyword">class </span>OptimizedSharpAngleDetector:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, world_bounds):</div>
<div class="line">        self.spatial_index = <a class="code hl_class" href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout.QuadTree</a>(world_bounds)</div>
<div class="line">        self.polygon_cache = {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>batch_detect_sharp_angles(self, polygons, threshold_degrees=30.0):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Optimized detection for multiple polygons.&quot;&quot;&quot;</span></div>
<div class="line">        results = {}</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Stage 1: Build spatial index</span></div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            self.spatial_index.insert(bbox, poly_id)</div>
<div class="line">            self.polygon_cache[poly_id] = polygon</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Stage 2: Process polygons with spatial locality</span></div>
<div class="line">        processed_regions = set()</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> poly_id, polygon <span class="keywordflow">in</span> enumerate(polygons):</div>
<div class="line">            <span class="keywordflow">if</span> poly_id <span class="keywordflow">in</span> processed_regions:</div>
<div class="line">                <span class="keywordflow">continue</span></div>
<div class="line">                </div>
<div class="line">            <span class="comment"># Find nearby polygons</span></div>
<div class="line">            bbox = polygon.bounding_box()</div>
<div class="line">            expanded_bbox = bbox.expand(50.0)  <span class="comment"># Expand for locality</span></div>
<div class="line">            nearby_ids = self.spatial_index.query_range(expanded_bbox)</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Process this region together</span></div>
<div class="line">            region_results = {}</div>
<div class="line">            <span class="keywordflow">for</span> nearby_id <span class="keywordflow">in</span> nearby_ids:</div>
<div class="line">                <span class="keywordflow">if</span> nearby_id <span class="keywordflow">not</span> <span class="keywordflow">in</span> processed_regions:</div>
<div class="line">                    nearby_polygon = self.polygon_cache[nearby_id]</div>
<div class="line">                    sharp_angles = self._detect_single_polygon(</div>
<div class="line">                        nearby_polygon, threshold_degrees</div>
<div class="line">                    )</div>
<div class="line">                    region_results[nearby_id] = sharp_angles</div>
<div class="line">                    processed_regions.add(nearby_id)</div>
<div class="line">            </div>
<div class="line">            results.update(region_results)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Performance comparison</span></div>
<div class="line">large_layout_polygons = generate_chip_layout(num_components=10000)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Method 1: Naive approach</span></div>
<div class="line">start_time = time.perf_counter()</div>
<div class="line">naive_results = []</div>
<div class="line"><span class="keywordflow">for</span> polygon <span class="keywordflow">in</span> large_layout_polygons:</div>
<div class="line">    sharp_angles = detector.detect_sharp_angles(polygon.vertices)</div>
<div class="line">    naive_results.append(sharp_angles)</div>
<div class="line">naive_time = time.perf_counter() - start_time</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Method 2: Spatially optimized</span></div>
<div class="line">start_time = time.perf_counter()</div>
<div class="line">optimized_detector = OptimizedSharpAngleDetector(world_bounds)</div>
<div class="line">optimized_results = optimized_detector.batch_detect_sharp_angles(</div>
<div class="line">    large_layout_polygons</div>
<div class="line">)</div>
<div class="line">optimized_time = time.perf_counter() - start_time</div>
<div class="line"> </div>
<div class="line">speedup = naive_time / optimized_time</div>
<div class="line">print(f<span class="stringliteral">&quot;Speedup: {speedup:.2f}x&quot;</span>)</div>
<div class="line"><span class="comment"># Expected: 2-4x speedup due to better cache locality</span></div>
<div class="ttc" id="aclasszlayout_1_1spatial_1_1_quad_tree_html"><div class="ttname"><a href="classzlayout_1_1spatial_1_1_quad_tree.html">zlayout::spatial::QuadTree</a></div><div class="ttdoc">Quadtree spatial index for efficient range and intersection queries.</div><div class="ttdef"><b>Definition</b> <a href="quadtree_8hpp_source.html#l00120">quadtree.hpp:120</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md116"></a>
Memory Access Patterns</h2>
<div class="fragment"><div class="line"><span class="comment"># Analysis of memory access patterns</span></div>
<div class="line"><span class="keyword">import</span> psutil</div>
<div class="line"><span class="keyword">import</span> os</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>monitor_memory_usage(func, *args, **kwargs):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Monitor memory usage during function execution.&quot;&quot;&quot;</span></div>
<div class="line">    process = psutil.Process(os.getpid())</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Baseline memory</span></div>
<div class="line">    mem_before = process.memory_info().rss / 1024 / 1024  <span class="comment"># MB</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Execute function</span></div>
<div class="line">    result = func(*args, **kwargs)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Peak memory</span></div>
<div class="line">    mem_after = process.memory_info().rss / 1024 / 1024  <span class="comment"># MB</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> result, mem_after - mem_before</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Compare memory usage patterns</span></div>
<div class="line">test_polygon = generate_test_polygon(100000)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Sequential access pattern</span></div>
<div class="line">result1, mem_usage1 = monitor_memory_usage(</div>
<div class="line">    detector.detect_sharp_angles, test_polygon</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Batch processing pattern  </span></div>
<div class="line">result2, mem_usage2 = monitor_memory_usage(</div>
<div class="line">    detector.batch_detect_sharp_angles, [test_polygon] * 100</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Sequential processing: {mem_usage1:.1f} MB&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Batch processing: {mem_usage2:.1f} MB&quot;</span>) </div>
<div class="line">print(f<span class="stringliteral">&quot;Memory efficiency: {mem_usage1/mem_usage2:.2f}x&quot;</span>)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md118"></a>
Real-world Applications</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
1. ASIC Design Rule Checking</h2>
<div class="fragment"><div class="line"><span class="comment"># Example: 7nm process node validation</span></div>
<div class="line"><span class="keyword">def </span>validate_asic_layout(layout_file, process_node=&quot;7nm&quot;):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Validate ASIC layout against process rules.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    process_rules = {</div>
<div class="line">        <span class="stringliteral">&quot;7nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 20.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.014},  <span class="comment"># 14nm spacing</span></div>
<div class="line">        <span class="stringliteral">&quot;5nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 15.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.010},  <span class="comment"># 10nm spacing</span></div>
<div class="line">        <span class="stringliteral">&quot;3nm&quot;</span>: {<span class="stringliteral">&quot;min_angle&quot;</span>: 12.0, <span class="stringliteral">&quot;min_spacing&quot;</span>: 0.008},  <span class="comment"># 8nm spacing</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    rules = process_rules[process_node]</div>
<div class="line">    layout = zlayout.load_layout(layout_file)</div>
<div class="line">    </div>
<div class="line">    violation_report = {</div>
<div class="line">        <span class="stringliteral">&quot;sharp_angles&quot;</span>: [],</div>
<div class="line">        <span class="stringliteral">&quot;spacing_violations&quot;</span>: [],</div>
<div class="line">        <span class="stringliteral">&quot;total_components&quot;</span>: len(layout.components)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Check each component</span></div>
<div class="line">    <span class="keywordflow">for</span> comp_id, component <span class="keywordflow">in</span> enumerate(layout.components):</div>
<div class="line">        <span class="comment"># Sharp angle check</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            component.geometry.vertices,</div>
<div class="line">            threshold_degrees=rules[<span class="stringliteral">&quot;min_angle&quot;</span>]</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> sharp_angles:</div>
<div class="line">            violation_report[<span class="stringliteral">&quot;sharp_angles&quot;</span>].append({</div>
<div class="line">                <span class="stringliteral">&quot;component_id&quot;</span>: comp_id,</div>
<div class="line">                <span class="stringliteral">&quot;component_name&quot;</span>: component.name,</div>
<div class="line">                <span class="stringliteral">&quot;violating_vertices&quot;</span>: sharp_angles,</div>
<div class="line">                <span class="stringliteral">&quot;severity&quot;</span>: <span class="stringliteral">&quot;critical&quot;</span> <span class="keywordflow">if</span> min([</div>
<div class="line">                    detector.calculate_vertex_angle(component.geometry.vertices, i) </div>
<div class="line">                    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> sharp_angles</div>
<div class="line">                ]) &lt; rules[<span class="stringliteral">&quot;min_angle&quot;</span>] * 0.5 <span class="keywordflow">else</span> <span class="stringliteral">&quot;warning&quot;</span></div>
<div class="line">            })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> violation_report</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Usage example</span></div>
<div class="line">report = validate_asic_layout(<span class="stringliteral">&quot;cpu_core_layout.gds&quot;</span>, <span class="stringliteral">&quot;7nm&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Found {len(report[&#39;sharp_angles&#39;])} components with sharp angle violations&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Generate detailed report</span></div>
<div class="line"><span class="keywordflow">for</span> violation <span class="keywordflow">in</span> report[<span class="stringliteral">&quot;sharp_angles&quot;</span>]:</div>
<div class="line">    <span class="keywordflow">if</span> violation[<span class="stringliteral">&quot;severity&quot;</span>] == <span class="stringliteral">&quot;critical&quot;</span>:</div>
<div class="line">        print(f<span class="stringliteral">&quot;CRITICAL: {violation[&#39;component_name&#39;]} has severe sharp angles&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md120"></a>
2. PCB Layout Optimization</h2>
<div class="fragment"><div class="line"><span class="comment"># PCB trace optimization for manufacturing</span></div>
<div class="line"><span class="keyword">def </span>optimize_pcb_traces(pcb_layout, target_impedance=50.0):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Optimize PCB traces while avoiding sharp angles.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    optimized_traces = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> trace <span class="keywordflow">in</span> pcb_layout.traces:</div>
<div class="line">        <span class="comment"># Detect sharp angles in trace path</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            trace.path_vertices, </div>
<div class="line">            threshold_degrees=30.0  <span class="comment"># PCB manufacturing limit</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> sharp_angles:</div>
<div class="line">            <span class="comment"># Apply corner rounding</span></div>
<div class="line">            optimized_path = round_sharp_corners(</div>
<div class="line">                trace.path_vertices, </div>
<div class="line">                sharp_angle_indices=sharp_angles,</div>
<div class="line">                radius=0.1  <span class="comment"># 0.1mm corner radius</span></div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Verify impedance is maintained</span></div>
<div class="line">            new_impedance = calculate_trace_impedance(optimized_path, trace.width)</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> abs(new_impedance - target_impedance) &lt; 2.0:  <span class="comment"># 2 ohm tolerance</span></div>
<div class="line">                optimized_traces.append(Trace(optimized_path, trace.width))</div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="comment"># Adjust trace width to maintain impedance</span></div>
<div class="line">                adjusted_width = adjust_width_for_impedance(</div>
<div class="line">                    optimized_path, target_impedance</div>
<div class="line">                )</div>
<div class="line">                optimized_traces.append(Trace(optimized_path, adjusted_width))</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            optimized_traces.append(trace)  <span class="comment"># No changes needed</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> optimized_traces</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md121"></a>
3. MEMS Device Design</h2>
<div class="fragment"><div class="line"><span class="comment"># Micro-electromechanical systems (MEMS) design validation</span></div>
<div class="line"><span class="keyword">def </span>validate_mems_design(mems_structure, material_properties):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Validate MEMS design for stress concentration.&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    stress_analysis = []</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> component <span class="keywordflow">in</span> mems_structure.mechanical_components:</div>
<div class="line">        <span class="comment"># Detect sharp angles that may cause stress concentration</span></div>
<div class="line">        sharp_angles = detector.detect_sharp_angles(</div>
<div class="line">            component.geometry.vertices,</div>
<div class="line">            threshold_degrees=45.0  <span class="comment"># MEMS typically need gentler angles</span></div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> angle_idx <span class="keywordflow">in</span> sharp_angles:</div>
<div class="line">            angle_value = detector.calculate_vertex_angle(</div>
<div class="line">                component.geometry.vertices, angle_idx</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Calculate stress concentration factor</span></div>
<div class="line">            stress_factor = calculate_stress_concentration(</div>
<div class="line">                angle_value, material_properties</div>
<div class="line">            )</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> stress_factor &gt; 3.0:  <span class="comment"># Critical threshold</span></div>
<div class="line">                stress_analysis.append({</div>
<div class="line">                    <span class="stringliteral">&quot;component&quot;</span>: component.name,</div>
<div class="line">                    <span class="stringliteral">&quot;vertex&quot;</span>: angle_idx,</div>
<div class="line">                    <span class="stringliteral">&quot;angle&quot;</span>: angle_value,</div>
<div class="line">                    <span class="stringliteral">&quot;stress_factor&quot;</span>: stress_factor,</div>
<div class="line">                    <span class="stringliteral">&quot;recommendation&quot;</span>: f<span class="stringliteral">&quot;Round corner with radius ≥ {0.5 * component.thickness:.3f}μm&quot;</span></div>
<div class="line">                })</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> stress_analysis</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md123"></a>
Advanced Topics</h1>
<h2><a class="anchor" id="autotoc_md124"></a>
Numerical Stability</h2>
<div class="fragment"><div class="line"><span class="comment"># Handling edge cases and numerical precision</span></div>
<div class="line"><span class="keyword">class </span>NumericallyStableDetector:</div>
<div class="line">    EPSILON = 1e-12</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>safe_acos(value):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Numerically stable arc cosine calculation.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Clamp to valid domain [-1, 1]</span></div>
<div class="line">        clamped = max(-1.0, min(1.0, value))</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Use alternative formula near boundaries</span></div>
<div class="line">        <span class="keywordflow">if</span> abs(clamped) &gt; 0.99999:</div>
<div class="line">            <span class="keywordflow">if</span> clamped &gt; 0:</div>
<div class="line">                <span class="keywordflow">return</span> math.sqrt(2 * (1 - clamped))  <span class="comment"># Near 0 degrees</span></div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                <span class="keywordflow">return</span> math.pi - math.sqrt(2 * (1 + clamped))  <span class="comment"># Near 180 degrees</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> math.acos(clamped)</div>
<div class="line">    </div>
<div class="line">    <span class="preprocessor">@classmethod</span>  </div>
<div class="line">    <span class="keyword">def </span>robust_angle_calculation(cls, v1, v2):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Calculate angle between vectors with numerical stability.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Calculate magnitudes</span></div>
<div class="line">        mag1 = math.sqrt(v1[0]**2 + v1[1]**2)</div>
<div class="line">        mag2 = math.sqrt(v2[0]**2 + v2[1]**2)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Check for degenerate vectors</span></div>
<div class="line">        <span class="keywordflow">if</span> mag1 &lt; cls.EPSILON <span class="keywordflow">or</span> mag2 &lt; cls.EPSILON:</div>
<div class="line">            <span class="keywordflow">return</span> float(<span class="stringliteral">&#39;nan&#39;</span>)  <span class="comment"># Undefined angle</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Normalize vectors</span></div>
<div class="line">        n1 = (v1[0] / mag1, v1[1] / mag1)</div>
<div class="line">        n2 = (v2[0] / mag2, v2[1] / mag2)</div>
<div class="line">        </div>
<div class="line">        <span class="comment"># Use atan2 for better numerical stability</span></div>
<div class="line">        cross_product = n1[0] * n2[1] - n1[1] * n2[0]</div>
<div class="line">        dot_product = n1[0] * n2[0] + n1[1] * n2[1]</div>
<div class="line">        </div>
<div class="line">        angle_rad = math.atan2(abs(cross_product), dot_product)</div>
<div class="line">        <span class="keywordflow">return</span> math.degrees(angle_rad)</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md126"></a>
Summary</h1>
<p>Sharp angle detection is a fundamental algorithm in EDA with <b>O(n) time complexity</b> and broad applications across ASIC, PCB, and MEMS design. Key takeaways:</p>
<p><b>Algorithm Efficiency:</b></p><ul>
<li>Linear time complexity O(n) per polygon</li>
<li>Constant space complexity O(1) for processing</li>
<li>Excellent cache locality for large datasets</li>
</ul>
<p><b>Optimization Strategies:</b></p><ul>
<li>Use <code>atan2</code> instead of <code>acos</code> for numerical stability</li>
<li>Batch processing for memory efficiency</li>
<li>Spatial indexing for multi-polygon layouts</li>
</ul>
<p><b>Real-world Impact:</b></p><ul>
<li>Essential for design rule checking (DRC)</li>
<li>Critical for manufacturing feasibility</li>
<li>Prevents stress concentration in MEMS devices</li>
</ul>
<p><b>Performance Characteristics:</b></p><ul>
<li>Scales linearly with polygon complexity</li>
<li>Memory-efficient implementation possible</li>
<li>Suitable for real-time applications</li>
</ul>
<p>For production use, combine the robust angle calculation with spatial indexing for optimal performance on large-scale EDA layouts. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
